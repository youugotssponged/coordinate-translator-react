{"version":3,"sources":["Common/colors.js","Common/fonts.js","Components/Header.js","Components/Footer.js","latlong_to_osgrid/math/dms.js","latlong_to_osgrid/math/vector3d.js","latlong_to_osgrid/math/latlon-ellipsoidal.js","latlong_to_osgrid/math/latlon-ellipsoidal-datum.js","latlong_to_osgrid/math/osgridref.js","latlong_to_osgrid/coord_converter.js","Components/LatLongArea.js","Components/OsgbArea.js","Components/BodyContainer.js","App.js","serviceWorker.js","index.js"],"names":["colors","lightPurple","darkBlue","steelGrey","errorRed","activeGreen","fonts","titleFont","footerFont","HeaderDiv","styled","div","Header","src","alt","FooterStyleDiv","Footer","href","dmsSeparator","Dms","dms","isNaN","parseFloat","isFinite","Number","dmsParts","String","trim","replace","split","length","splice","NaN","deg","test","format","dp","undefined","Infinity","Math","abs","d","m","s","toFixed","floor","slice","separator","lat","toDms","wrap90","lon","wrap180","brng","wrap360","str","locale","toLocaleString","thousands","decimal","bearing","precision","includes","RangeError","cardinals","n","cardinal","round","degrees","char","prototype","toRadians","this","PI","toDegrees","Vector3d","x","y","z","TypeError","v","norm","sign","cross","dot","sinθ","cosθ","atan2","axis","angle","θ","p","unit","a","sin","c","cos","t","r","rp","sqrt","ellipsoids","WGS84","b","f","datums","ellipsoid","Object","freeze","LatLonEllipsoidal","height","_lat","_lon","_height","datum","referenceFrame","φ","λ","h","sinφ","cosφ","sinλ","cosλ","eSq","ν","Cartesian","point","EPSILON","epoch","dpHeight","toLat","toLon","parse","_datum","args","ll","type","Array","isArray","coordinates","latitude","longitude","lng","JSON","stringify","toString","e2","ε2","R","tanβ","sinβ","cosβ","Airy1830","AiryModified","Bessel1841","Clarke1866","Clarke1880IGN","GRS80","Intl1924","WGS72","ED50","transform","ETRS89","Irl1975","NAD27","NAD83","NTF","OSGB36","Potsdam","TokyoJapan","keys","forEach","e","LatLonEllipsoidal_Datum","toDatum","toCartesian","convertDatum","toLatLon","cartesian","Cartesian_Datum","pop","deprecatedDatum","console","info","latLon","oldCartesian","map","newCartesian","applyTransform","x1","y1","z1","tx","ty","tz","rx","ry","rz","OsGridRef","easting","northing","E","N","F0","φ0","λ0","N0","E0","n2","n3","M","Ma","Mb","Mc","Md","ρ","pow","η2","tanφ","tan","tan2φ","tan4φ","tan6φ","secφ","ν3","ν5","ν7","VII","VIII","IX","X","XI","XII","XIIA","dE","dE2","dE3","dE4","dE5","dE6","dE7","LatLon_OsGridRef","digits","useGrouping","minimumIntegerDigits","maximumFractionDigits","ePad","nPad","e100km","n100km","l1","l2","letterPair","fromCharCode","charCodeAt","padStart","gridref","match","Error","toUpperCase","en","padEnd","cos3φ","cos5φ","Δλ","Δλ2","Δλ3","Δλ4","Δλ5","message","CoordConverter","long","latlong","LatLon","toOsGrid","latdeg","latmin","latsec","longdeg","longmin","longsec","LAT","getDecimalFromDegree","LONG","osref","min","sec","decDeg","dec","posDec","LatLongAreaStyled","LatLongArea","props","useState","isDecimal","setIsDecimal","buttonPlaceHolder","setButtonPlaceHolder","input1Ref","useRef","input2Ref","outputRef","converter","Converter","CheckDecimalToDegree","ref","className","placeholder","onClick","current","value","result","getOSGB_FromDec","ceil","getDegreeFromDecimal","londeg","lonmin","lonsec","table","getOSGB_FromDMS","error","alert","log","OSGBAreaStyled","OsgbArea","eastingInput","northingInput","getLatLong_FromOSGB","BodyContainerDiv","ImageArrow","img","flipDirection","LatLongButton","button","activeColor","OsgbButton","BodyContainer","LatLongButtonClicked","setLatLongButtonClicked","OsgbButtonClicked","setOsgbButtonClicked","disabled","PageGridContainerDiv","App","Helmet","rel","Boolean","window","location","hostname","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch"],"mappings":"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","file":"static/js/main.e57abd4e.chunk.js","sourcesContent":["const colors = {\r\n    lightPurple: \"#C7CEDB\",\r\n    darkBlue: \"#14213D\",\r\n    steelGrey: \"#C4C4C4\",\r\n    errorRed: \"#FC2F00\",\r\n    activeGreen: '#46CA1D',\r\n};\r\n\r\nexport default colors;\r\n","const fonts = {\r\n    titleFont: \"ABeeZee\",\r\n    footerFont: \"Fredoka One\",\r\n}\r\n\r\nexport default fonts;","import React from \"react\";\r\nimport styled from \"styled-components\";\r\n\r\nimport colors from '../Common/colors';\r\nimport fonts from '../Common/fonts';\r\n\r\nconst HeaderDiv = styled.div`\r\n    grid-column: 1/13;\r\n    display: grid;\r\n    grid-template-columns: 2fr repeat(10, 1fr) 2fr;\r\n    background-color: ${colors.darkBlue};\r\n    color: white;\r\n    box-shadow: 0px 0px 50px ${colors.darkBlue};\r\n\r\n    & h1 {\r\n        grid-column: 2/11;\r\n        font-family: ${fonts.titleFont};\r\n        font-size: 4vw;\r\n        font-weight: bold;\r\n        text-align: center;\r\n        padding-top: 15px;\r\n        white-space: nowrap; \r\n    }\r\n\r\n    & img {\r\n        grid-column: 11/12;\r\n        filter: invert(1);\r\n    }\r\n\r\n    & img:hover {\r\n        filter: invert(0);\r\n    }\r\n`;\r\n\r\nconst Header = () => {\r\n    return (\r\n        <HeaderDiv>\r\n            <h1> Coordinate To OSGB Converter</h1>\r\n            <img\r\n                src=\"/img/os_grid_icon.png\"\r\n                alt=\"OS GRID logo from FunkyPenguin10's Flutter App\"\r\n            ></img>\r\n        </HeaderDiv>\r\n    );\r\n}\r\n\r\nexport default Header;","import React from \"react\";\r\nimport styled from \"styled-components\";\r\n\r\nimport colors from \"../Common/colors\";\r\nimport fonts from \"../Common/fonts\";\r\n\r\nconst FooterStyleDiv = styled.div`\r\n    display: grid;\r\n    grid-row: 15/16;\r\n    grid-column: 1/13;\r\n    box-shadow: 0px 0px 50px ${colors.darkBlue};\r\n    background-color: ${colors.darkBlue};\r\n\r\n    color: white;\r\n    grid-template-columns: 2fr 2fr 2fr;\r\n \r\n    & h1 {\r\n        font-family: ${fonts.footerFont};\r\n        font-size: 1.5vw;\r\n        margin: 0 auto;\r\n    }\r\n\r\n    & img {\r\n        padding-top: 15px;\r\n        display: block;\r\n        margin: 0 auto;\r\n    }\r\n\r\n    & img:hover {\r\n        filter: invert(70%);\r\n    }\r\n`;\r\n\r\nconst Footer = () => {\r\n    return (\r\n        <FooterStyleDiv>\r\n            <a href=\"https://www.twitch.tv/youugotssponged/\">\r\n                <img\r\n                    src=\"/img/twitch-tv-2-64.png\"\r\n                    alt=\"Link to my Twitch\"\r\n                />\r\n            </a>\r\n            <a href=\"https://www.github.com/youugotssponged/\">\r\n                <img\r\n                    src=\"/img/GitHub-Mark-Light-64px.png\"\r\n                    alt=\"Link to my github\"\r\n                />\r\n            </a>\r\n            <a href=\"https://www.linkedin.com/in/jordan-mccann-b808b4156/\">\r\n                <img src=\"/img/linkedin-64.png\" alt=\"Link to my LinkedIn\" />\r\n            </a>\r\n            <h1>youugotssponged</h1>\r\n            <h1>youugotssponged</h1>\r\n            <h1>Jordan McCann</h1>\r\n        </FooterStyleDiv>\r\n    );\r\n};\r\n\r\nexport default Footer;\r\n","/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\r\n/* Geodesy representation conversion functions                        (c) Chris Veness 2002-2019  */\r\n/*                                                                                   MIT Licence  */\r\n/* www.movable-type.co.uk/scripts/latlong.html                                                    */\r\n/* www.movable-type.co.uk/scripts/js/geodesy/geodesy-library.html#dms                             */\r\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\r\n\r\n/* eslint no-irregular-whitespace: [2, { skipComments: true }] */\r\n\r\n\r\n/**\r\n * Latitude/longitude points may be represented as decimal degrees, or subdivided into sexagesimal\r\n * minutes and seconds. This module provides methods for parsing and representing degrees / minutes\r\n * / seconds.\r\n *\r\n * @module dms\r\n */\r\n\r\n\r\n/* Degree-minutes-seconds (& cardinal directions) separator character */\r\nlet dmsSeparator = '\\u202f'; // U+202F = 'narrow no-break space'\r\n\r\n\r\n/**\r\n * Functions for parsing and representing degrees / minutes / seconds.\r\n */\r\nclass Dms {\r\n\r\n    // note Unicode Degree = U+00B0. Prime = U+2032, Double prime = U+2033\r\n\r\n    /**\r\n     * Separator character to be used to separate degrees, minutes, seconds, and cardinal directions.\r\n     *\r\n     * Default separator is U+202F ‘narrow no-break space’.\r\n     *\r\n     * To change this (e.g. to empty string or full space), set Dms.separator prior to invoking\r\n     * formatting.\r\n     *\r\n     * @example\r\n     *   import LatLon, { Dms } from '/js/geodesy/latlon-spherical.js';\r\n     *   const p = new LatLon(51.2, 0.33).toString('dms');  // 51° 12′ 00″ N, 000° 19′ 48″ E\r\n     *   Dms.separator = '';                                // no separator\r\n     *   const pʹ = new LatLon(51.2, 0.33).toString('dms'); // 51°12′00″N, 000°19′48″E\r\n     */\r\n    static get separator()     { return dmsSeparator; }\r\n    static set separator(char) { dmsSeparator = char; }\r\n\r\n\r\n    /**\r\n     * Parses string representing degrees/minutes/seconds into numeric degrees.\r\n     *\r\n     * This is very flexible on formats, allowing signed decimal degrees, or deg-min-sec optionally\r\n     * suffixed by compass direction (NSEW); a variety of separators are accepted. Examples -3.62,\r\n     * '3 37 12W', '3°37′12″W'.\r\n     *\r\n     * Thousands/decimal separators must be comma/dot; use Dms.fromLocale to convert locale-specific\r\n     * thousands/decimal separators.\r\n     *\r\n     * @param   {string|number} dms - Degrees or deg/min/sec in variety of formats.\r\n     * @returns {number}        Degrees as decimal number.\r\n     *\r\n     * @example\r\n     *   const lat = Dms.parse('51° 28′ 40.37″ N');\r\n     *   const lon = Dms.parse('000° 00′ 05.29″ W');\r\n     *   const p1 = new LatLon(lat, lon); // 51.4779°N, 000.0015°W\r\n     */\r\n    static parse(dms) {\r\n        // check for signed decimal degrees without NSEW, if so return it directly\r\n        if (!isNaN(parseFloat(dms)) && isFinite(dms)) return Number(dms);\r\n\r\n        // strip off any sign or compass dir'n & split out separate d/m/s\r\n        const dmsParts = String(dms).trim().replace(/^-/, '').replace(/[NSEW]$/i, '').split(/[^0-9.,]+/);\r\n        if (dmsParts[dmsParts.length-1]=='') dmsParts.splice(dmsParts.length-1);  // from trailing symbol\r\n\r\n        if (dmsParts == '') return NaN;\r\n\r\n        // and convert to decimal degrees...\r\n        let deg = null;\r\n        switch (dmsParts.length) {\r\n            case 3:  // interpret 3-part result as d/m/s\r\n                deg = dmsParts[0]/1 + dmsParts[1]/60 + dmsParts[2]/3600;\r\n                break;\r\n            case 2:  // interpret 2-part result as d/m\r\n                deg = dmsParts[0]/1 + dmsParts[1]/60;\r\n                break;\r\n            case 1:  // just d (possibly decimal) or non-separated dddmmss\r\n                deg = dmsParts[0];\r\n                // check for fixed-width unseparated format eg 0033709W\r\n                //if (/[NS]/i.test(dmsParts)) deg = '0' + deg;  // - normalise N/S to 3-digit degrees\r\n                //if (/[0-9]{7}/.test(deg)) deg = deg.slice(0,3)/1 + deg.slice(3,5)/60 + deg.slice(5)/3600;\r\n                break;\r\n            default:\r\n                return NaN;\r\n        }\r\n        if (/^-|[WS]$/i.test(dms.trim())) deg = -deg; // take '-', west and south as -ve\r\n\r\n        return Number(deg);\r\n    }\r\n\r\n\r\n    /**\r\n     * Converts decimal degrees to deg/min/sec format\r\n     *  - degree, prime, double-prime symbols are added, but sign is discarded, though no compass\r\n     *    direction is added.\r\n     *  - degrees are zero-padded to 3 digits; for degrees latitude, use .slice(1) to remove leading\r\n     *    zero.\r\n     *\r\n     * @private\r\n     * @param   {number} deg - Degrees to be formatted as specified.\r\n     * @param   {string} [format=d] - Return value as 'd', 'dm', 'dms' for deg, deg+min, deg+min+sec.\r\n     * @param   {number} [dp=4|2|0] - Number of decimal places to use – default 4 for d, 2 for dm, 0 for dms.\r\n     * @returns {string} Degrees formatted as deg/min/secs according to specified format.\r\n     */\r\n    static toDms(deg, format='d', dp=undefined) {\r\n        if (isNaN(deg)) return null;  // give up here if we can't make a number from deg\r\n        if (typeof deg == 'string' && deg.trim() == '') return null;\r\n        if (typeof deg == 'boolean') return null;\r\n        if (deg == Infinity) return null;\r\n        if (deg == null) return null;\r\n\r\n        // default values\r\n        if (dp === undefined) {\r\n            switch (format) {\r\n                case 'd':   case 'deg':         dp = 4; break;\r\n                case 'dm':  case 'deg+min':     dp = 2; break;\r\n                case 'dms': case 'deg+min+sec': dp = 0; break;\r\n                default:          format = 'd'; dp = 4; break; // be forgiving on invalid format\r\n            }\r\n        }\r\n\r\n        deg = Math.abs(deg);  // (unsigned result ready for appending compass dir'n)\r\n\r\n        let dms = null, d = null, m = null, s = null;\r\n        switch (format) {\r\n            default: // invalid format spec!\r\n            case 'd': case 'deg':\r\n                d = deg.toFixed(dp);                       // round/right-pad degrees\r\n                if (d<100) d = '0' + d;                    // left-pad with leading zeros (note may include decimals)\r\n                if (d<10) d = '0' + d;\r\n                dms = d + '°';\r\n                break;\r\n            case 'dm': case 'deg+min':\r\n                d = Math.floor(deg);                       // get component deg\r\n                m = ((deg*60) % 60).toFixed(dp);           // get component min & round/right-pad\r\n                if (m == 60) { m = (0).toFixed(dp); d++; } // check for rounding up\r\n                d = ('000'+d).slice(-3);                   // left-pad with leading zeros\r\n                if (m<10) m = '0' + m;                     // left-pad with leading zeros (note may include decimals)\r\n                dms = d + '°'+Dms.separator + m + '′';\r\n                break;\r\n            case 'dms': case 'deg+min+sec':\r\n                d = Math.floor(deg);                       // get component deg\r\n                m = Math.floor((deg*3600)/60) % 60;        // get component min\r\n                s = (deg*3600 % 60).toFixed(dp);           // get component sec & round/right-pad\r\n                if (s == 60) { s = (0).toFixed(dp); m++; } // check for rounding up\r\n                if (m == 60) { m = 0; d++; }               // check for rounding up\r\n                d = ('000'+d).slice(-3);                   // left-pad with leading zeros\r\n                m = ('00'+m).slice(-2);                    // left-pad with leading zeros\r\n                if (s<10) s = '0' + s;                     // left-pad with leading zeros (note may include decimals)\r\n                dms = d + '°'+Dms.separator + m + '′'+Dms.separator + s + '″';\r\n                break;\r\n        }\r\n\r\n        return dms;\r\n    }\r\n\r\n\r\n    /**\r\n     * Converts numeric degrees to deg/min/sec latitude (2-digit degrees, suffixed with N/S).\r\n     *\r\n     * @param   {number} deg - Degrees to be formatted as specified.\r\n     * @param   {string} [format=d] - Return value as 'd', 'dm', 'dms' for deg, deg+min, deg+min+sec.\r\n     * @param   {number} [dp=4|2|0] - Number of decimal places to use – default 4 for d, 2 for dm, 0 for dms.\r\n     * @returns {string} Degrees formatted as deg/min/secs according to specified format.\r\n     *\r\n     * @example\r\n     *   const lat = Dms.toLat(-3.62, 'dms'); // 3°37′12″S\r\n     */\r\n    static toLat(deg, format, dp) {\r\n        const lat = Dms.toDms(Dms.wrap90(deg), format, dp);\r\n        return lat===null ? '–' : lat.slice(1) + Dms.separator + (deg<0 ? 'S' : 'N');  // knock off initial '0' for lat!\r\n    }\r\n\r\n\r\n    /**\r\n     * Convert numeric degrees to deg/min/sec longitude (3-digit degrees, suffixed with E/W).\r\n     *\r\n     * @param   {number} deg - Degrees to be formatted as specified.\r\n     * @param   {string} [format=d] - Return value as 'd', 'dm', 'dms' for deg, deg+min, deg+min+sec.\r\n     * @param   {number} [dp=4|2|0] - Number of decimal places to use – default 4 for d, 2 for dm, 0 for dms.\r\n     * @returns {string} Degrees formatted as deg/min/secs according to specified format.\r\n     *\r\n     * @example\r\n     *   const lon = Dms.toLon(-3.62, 'dms'); // 3°37′12″W\r\n     */\r\n    static toLon(deg, format, dp) {\r\n        const lon = Dms.toDms(Dms.wrap180(deg), format, dp);\r\n        return lon===null ? '–' : lon + Dms.separator + (deg<0 ? 'W' : 'E');\r\n    }\r\n\r\n\r\n    /**\r\n     * Converts numeric degrees to deg/min/sec as a bearing (0°..360°).\r\n     *\r\n     * @param   {number} deg - Degrees to be formatted as specified.\r\n     * @param   {string} [format=d] - Return value as 'd', 'dm', 'dms' for deg, deg+min, deg+min+sec.\r\n     * @param   {number} [dp=4|2|0] - Number of decimal places to use – default 4 for d, 2 for dm, 0 for dms.\r\n     * @returns {string} Degrees formatted as deg/min/secs according to specified format.\r\n     *\r\n     * @example\r\n     *   const lon = Dms.toBrng(-3.62, 'dms'); // 356°22′48″\r\n     */\r\n    static toBrng(deg, format, dp) {\r\n        const brng =  Dms.toDms(Dms.wrap360(deg), format, dp);\r\n        return brng===null ? '–' : brng.replace('360', '0');  // just in case rounding took us up to 360°!\r\n    }\r\n\r\n\r\n    /**\r\n     * Converts DMS string from locale thousands/decimal separators to JavaScript comma/dot separators\r\n     * for subsequent parsing.\r\n     *\r\n     * Both thousands and decimal separators must be followed by a numeric character, to facilitate\r\n     * parsing of single lat/long string (in which whitespace must be left after the comma separator).\r\n     *\r\n     * @param   {string} str - Degrees/minutes/seconds formatted with locale separators.\r\n     * @returns {string} Degrees/minutes/seconds formatted with standard Javascript separators.\r\n     *\r\n     * @example\r\n     *   const lat = Dms.fromLocale('51°28′40,12″N');                          // '51°28′40.12″N' in France\r\n     *   const p = new LatLon(Dms.fromLocale('51°28′40,37″N, 000°00′05,29″W'); // '51.4779°N, 000.0015°W' in France\r\n     */\r\n    static fromLocale(str) {\r\n        const locale = (123456.789).toLocaleString();\r\n        const separator = { thousands: locale.slice(3, 4), decimal: locale.slice(7, 8) };\r\n        return str.replace(separator.thousands, '⁜').replace(separator.decimal, '.').replace('⁜', ',');\r\n    }\r\n\r\n\r\n    /**\r\n     * Converts DMS string from JavaScript comma/dot thousands/decimal separators to locale separators.\r\n     *\r\n     * Can also be used to format standard numbers such as distances.\r\n     *\r\n     * @param   {string} str - Degrees/minutes/seconds formatted with standard Javascript separators.\r\n     * @returns {string} Degrees/minutes/seconds formatted with locale separators.\r\n     *\r\n     * @example\r\n     *   const Dms.toLocale('123,456.789');                   // '123.456,789' in France\r\n     *   const Dms.toLocale('51°28′40.12″N, 000°00′05.31″W'); // '51°28′40,12″N, 000°00′05,31″W' in France\r\n     */\r\n    static toLocale(str) {\r\n        const locale = (123456.789).toLocaleString();\r\n        const separator = { thousands: locale.slice(3, 4), decimal: locale.slice(7, 8) };\r\n        return str.replace(/,([0-9])/, '⁜$1').replace('.', separator.decimal).replace('⁜', separator.thousands);\r\n    }\r\n\r\n\r\n    /**\r\n     * Returns compass point (to given precision) for supplied bearing.\r\n     *\r\n     * @param   {number} bearing - Bearing in degrees from north.\r\n     * @param   {number} [precision=3] - Precision (1:cardinal / 2:intercardinal / 3:secondary-intercardinal).\r\n     * @returns {string} Compass point for supplied bearing.\r\n     *\r\n     * @example\r\n     *   const point = Dms.compassPoint(24);    // point = 'NNE'\r\n     *   const point = Dms.compassPoint(24, 1); // point = 'N'\r\n     */\r\n    static compassPoint(bearing, precision=3) {\r\n        if (![ 1, 2, 3 ].includes(Number(precision))) throw new RangeError(`invalid precision ‘${precision}’`);\r\n        // note precision could be extended to 4 for quarter-winds (eg NbNW), but I think they are little used\r\n\r\n        bearing = Dms.wrap360(bearing); // normalise to range 0..360°\r\n\r\n        const cardinals = [\r\n            'N', 'NNE', 'NE', 'ENE',\r\n            'E', 'ESE', 'SE', 'SSE',\r\n            'S', 'SSW', 'SW', 'WSW',\r\n            'W', 'WNW', 'NW', 'NNW' ];\r\n        const n = 4 * 2**(precision-1); // no of compass points at req’d precision (1=>4, 2=>8, 3=>16)\r\n        const cardinal = cardinals[Math.round(bearing*n/360)%n * 16/n];\r\n\r\n        return cardinal;\r\n    }\r\n\r\n\r\n    /**\r\n     * Constrain degrees to range 0..360 (e.g. for bearings); -1 => 359, 361 => 1.\r\n     *\r\n     * @private\r\n     * @param {number} degrees\r\n     * @returns degrees within range 0..360.\r\n     */\r\n    static wrap360(degrees) {\r\n        if (0<=degrees && degrees<360) return degrees; // avoid rounding due to arithmetic ops if within range\r\n        return (degrees%360+360) % 360; // sawtooth wave p:360, a:360\r\n    }\r\n\r\n    /**\r\n     * Constrain degrees to range -180..+180 (e.g. for longitude); -181 => 179, 181 => -179.\r\n     *\r\n     * @private\r\n     * @param {number} degrees\r\n     * @returns degrees within range -180..+180.\r\n     */\r\n    static wrap180(degrees) {\r\n        if (-180<degrees && degrees<=180) return degrees; // avoid rounding due to arithmetic ops if within range\r\n        return (degrees+540)%360-180; // sawtooth wave p:180, a:±180\r\n    }\r\n\r\n    /**\r\n     * Constrain degrees to range -90..+90 (e.g. for latitude); -91 => -89, 91 => 89.\r\n     *\r\n     * @private\r\n     * @param {number} degrees\r\n     * @returns degrees within range -90..+90.\r\n     */\r\n    static wrap90(degrees) {\r\n        if (-90<=degrees && degrees<=90) return degrees; // avoid rounding due to arithmetic ops if within range\r\n        return Math.abs((degrees%360 + 270)%360 - 180) - 90; // triangle wave p:360 a:±90 TODO: fix e.g. -315°\r\n    }\r\n\r\n}\r\n\r\n\r\n// Extend Number object with methods to convert between degrees & radians\r\nNumber.prototype.toRadians = function() { return this * Math.PI / 180; };\r\nNumber.prototype.toDegrees = function() { return this * 180 / Math.PI; };\r\n\r\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\r\n\r\nexport default Dms;\r\n","/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\r\n/* Vector handling functions                                          (c) Chris Veness 2011-2019  */\r\n/*                                                                                   MIT Licence  */\r\n/* www.movable-type.co.uk/scripts/geodesy-library.html#vector3d                                   */\r\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\r\n\r\n\r\n/**\r\n * Library of 3-d vector manipulation routines.\r\n *\r\n * @module vector3d\r\n */\r\n\r\n\r\n/* Vector3d - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\r\n\r\n\r\n/**\r\n * Functions for manipulating generic 3-d vectors.\r\n *\r\n * Functions return vectors as return results, so that operations can be chained.\r\n *\r\n * @example\r\n *   const v = v1.cross(v2).dot(v3) // ≡ v1×v2⋅v3\r\n */\r\nclass Vector3d {\r\n\r\n    /**\r\n     * Creates a 3-d vector.\r\n     *\r\n     * @param {number} x - X component of vector.\r\n     * @param {number} y - Y component of vector.\r\n     * @param {number} z - Z component of vector.\r\n     *\r\n     * @example\r\n     *   import Vector3d from '/js/geodesy/vector3d.js';\r\n     *   const v = new Vector3d(0.267, 0.535, 0.802);\r\n     */\r\n    constructor(x, y, z) {\r\n        if (isNaN(x) || isNaN(x) || isNaN(x)) throw new TypeError(`invalid vector [${x},${y},${z}]`);\r\n\r\n        this.x = Number(x);\r\n        this.y = Number(y);\r\n        this.z = Number(z);\r\n    }\r\n\r\n\r\n    /**\r\n     * Length (magnitude or norm) of ‘this’ vector.\r\n     *\r\n     * @returns {number} Magnitude of this vector.\r\n     */\r\n    get length() {\r\n        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\r\n    }\r\n\r\n\r\n    /**\r\n     * Adds supplied vector to ‘this’ vector.\r\n     *\r\n     * @param   {Vector3d} v - Vector to be added to this vector.\r\n     * @returns {Vector3d} Vector representing sum of this and v.\r\n     */\r\n    plus(v) {\r\n        if (!(v instanceof Vector3d)) throw new TypeError('v is not Vector3d object');\r\n\r\n        return new Vector3d(this.x + v.x, this.y + v.y, this.z + v.z);\r\n    }\r\n\r\n\r\n    /**\r\n     * Subtracts supplied vector from ‘this’ vector.\r\n     *\r\n     * @param   {Vector3d} v - Vector to be subtracted from this vector.\r\n     * @returns {Vector3d} Vector representing difference between this and v.\r\n     */\r\n    minus(v) {\r\n        if (!(v instanceof Vector3d)) throw new TypeError('v is not Vector3d object');\r\n\r\n        return new Vector3d(this.x - v.x, this.y - v.y, this.z - v.z);\r\n    }\r\n\r\n\r\n    /**\r\n     * Multiplies ‘this’ vector by a scalar value.\r\n     *\r\n     * @param   {number}   x - Factor to multiply this vector by.\r\n     * @returns {Vector3d} Vector scaled by x.\r\n     */\r\n    times(x) {\r\n        if (isNaN(x)) throw new TypeError(`invalid scalar value ‘${x}’`);\r\n\r\n        return new Vector3d(this.x * x, this.y * x, this.z * x);\r\n    }\r\n\r\n\r\n    /**\r\n     * Divides ‘this’ vector by a scalar value.\r\n     *\r\n     * @param   {number}   x - Factor to divide this vector by.\r\n     * @returns {Vector3d} Vector divided by x.\r\n     */\r\n    dividedBy(x) {\r\n        if (isNaN(x)) throw new TypeError(`invalid scalar value ‘${x}’`);\r\n\r\n        return new Vector3d(this.x / x, this.y / x, this.z / x);\r\n    }\r\n\r\n\r\n    /**\r\n     * Multiplies ‘this’ vector by the supplied vector using dot (scalar) product.\r\n     *\r\n     * @param   {Vector3d} v - Vector to be dotted with this vector.\r\n     * @returns {number}   Dot product of ‘this’ and v.\r\n     */\r\n    dot(v) {\r\n        if (!(v instanceof Vector3d)) throw new TypeError('v is not Vector3d object');\r\n\r\n        return this.x * v.x + this.y * v.y + this.z * v.z;\r\n    }\r\n\r\n\r\n    /**\r\n     * Multiplies ‘this’ vector by the supplied vector using cross (vector) product.\r\n     *\r\n     * @param   {Vector3d} v - Vector to be crossed with this vector.\r\n     * @returns {Vector3d} Cross product of ‘this’ and v.\r\n     */\r\n    cross(v) {\r\n        if (!(v instanceof Vector3d)) throw new TypeError('v is not Vector3d object');\r\n\r\n        const x = this.y * v.z - this.z * v.y;\r\n        const y = this.z * v.x - this.x * v.z;\r\n        const z = this.x * v.y - this.y * v.x;\r\n\r\n        return new Vector3d(x, y, z);\r\n    }\r\n\r\n\r\n    /**\r\n     * Negates a vector to point in the opposite direction.\r\n     *\r\n     * @returns {Vector3d} Negated vector.\r\n     */\r\n    negate() {\r\n        return new Vector3d(-this.x, -this.y, -this.z);\r\n    }\r\n\r\n\r\n    /**\r\n     * Normalizes a vector to its unit vector\r\n     * – if the vector is already unit or is zero magnitude, this is a no-op.\r\n     *\r\n     * @returns {Vector3d} Normalised version of this vector.\r\n     */\r\n    unit() {\r\n        const norm = this.length;\r\n        if (norm == 1) return this;\r\n        if (norm == 0) return this;\r\n\r\n        const x = this.x / norm;\r\n        const y = this.y / norm;\r\n        const z = this.z / norm;\r\n\r\n        return new Vector3d(x, y, z);\r\n    }\r\n\r\n\r\n    /**\r\n     * Calculates the angle between ‘this’ vector and supplied vector atan2(|p₁×p₂|, p₁·p₂) (or if\r\n     * (extra-planar) ‘n’ supplied then atan2(n·p₁×p₂, p₁·p₂).\r\n     *\r\n     * @param   {Vector3d} v - Vector whose angle is to be determined from ‘this’ vector.\r\n     * @param   {Vector3d} [n] - Plane normal: if supplied, angle is signed +ve if this->v is\r\n     *                     clockwise looking along n, -ve in opposite direction.\r\n     * @returns {number}   Angle (in radians) between this vector and supplied vector (in range 0..π\r\n     *                     if n not supplied, range -π..+π if n supplied).\r\n     */\r\n    angleTo(v, n=undefined) {\r\n        if (!(v instanceof Vector3d)) throw new TypeError('v is not Vector3d object');\r\n        if (!(n instanceof Vector3d || n == undefined)) throw new TypeError('n is not Vector3d object');\r\n\r\n        // q.v. stackoverflow.com/questions/14066933#answer-16544330, but n·p₁×p₂ is numerically\r\n        // ill-conditioned, so just calculate sign to apply to |p₁×p₂|\r\n\r\n        // if n·p₁×p₂ is -ve, negate |p₁×p₂|\r\n        const sign = n==undefined || this.cross(v).dot(n)>=0 ? 1 : -1;\r\n\r\n        const sinθ = this.cross(v).length * sign;\r\n        const cosθ = this.dot(v);\r\n\r\n        return Math.atan2(sinθ, cosθ);\r\n    }\r\n\r\n\r\n    /**\r\n     * Rotates ‘this’ point around an axis by a specified angle.\r\n     *\r\n     * @param   {Vector3d} axis - The axis being rotated around.\r\n     * @param   {number}   angle - The angle of rotation (in degrees).\r\n     * @returns {Vector3d} The rotated point.\r\n     */\r\n    rotateAround(axis, angle) {\r\n        if (!(axis instanceof Vector3d)) throw new TypeError('axis is not Vector3d object');\r\n\r\n        const θ = angle.toRadians();\r\n\r\n        // en.wikipedia.org/wiki/Rotation_matrix#Rotation_matrix_from_axis_and_angle\r\n        // en.wikipedia.org/wiki/Quaternions_and_spatial_rotation#Quaternion-derived_rotation_matrix\r\n        const p = this.unit();\r\n        const a = axis.unit();\r\n\r\n        const s = Math.sin(θ);\r\n        const c = Math.cos(θ);\r\n        const t = 1-c;\r\n        const x = a.x, y = a.y, z = a.z;\r\n\r\n        const r = [ // rotation matrix for rotation about supplied axis\r\n            [ t*x*x + c,   t*x*y - s*z, t*x*z + s*y ],\r\n            [ t*x*y + s*z, t*y*y + c,   t*y*z - s*x ],\r\n            [ t*x*z - s*y, t*y*z + s*x, t*z*z + c   ],\r\n        ];\r\n\r\n        // multiply r × p\r\n        const rp = [\r\n            r[0][0]*p.x + r[0][1]*p.y + r[0][2]*p.z,\r\n            r[1][0]*p.x + r[1][1]*p.y + r[1][2]*p.z,\r\n            r[2][0]*p.x + r[2][1]*p.y + r[2][2]*p.z,\r\n        ];\r\n        const p2 = new Vector3d(rp[0], rp[1], rp[2]);\r\n\r\n        return p2;\r\n        // qv en.wikipedia.org/wiki/Rodrigues'_rotation_formula...\r\n    }\r\n\r\n\r\n    /**\r\n     * String representation of vector.\r\n     *\r\n     * @param   {number} [dp=3] - Number of decimal places to be used.\r\n     * @returns {string} Vector represented as [x,y,z].\r\n     */\r\n    toString(dp=3) {\r\n        return `[${this.x.toFixed(dp)},${this.y.toFixed(dp)},${this.z.toFixed(dp)}]`;\r\n    }\r\n\r\n}\r\n\r\n\r\n// Extend Number object with methods to convert between degrees & radians\r\nNumber.prototype.toRadians = function() { return this * Math.PI / 180; };\r\nNumber.prototype.toDegrees = function() { return this * 180 / Math.PI; };\r\n\r\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\r\n\r\nexport default Vector3d;\r\n","/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\r\n/* Geodesy tools for an ellipsoidal earth model                       (c) Chris Veness 2005-2019  */\r\n/*                                                                                   MIT Licence  */\r\n/* www.movable-type.co.uk/scripts/latlong-convert-coords.html                                     */\r\n/* www.movable-type.co.uk/scripts/geodesy-library.html#latlon-ellipsoidal                         */\r\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\r\n\r\nimport Dms      from './dms.js';\r\nimport Vector3d from './vector3d.js';\r\n\r\n\r\n/**\r\n * A latitude/longitude point defines a geographic location on or above/below the earth’s surface,\r\n * measured in degrees from the equator & the International Reference Meridian and in metres above\r\n * the ellipsoid, and based on a given datum.\r\n *\r\n * As so much modern geodesy is based on WGS-84 (as used by GPS), this module includes WGS-84\r\n * ellipsoid parameters, and it has methods for converting geodetic (latitude/longitude) points to/from\r\n * geocentric cartesian points; the latlon-ellipsoidal-datum and latlon-ellipsoidal-referenceframe\r\n * modules provide transformation parameters for converting between historical datums and between\r\n * modern reference frames.\r\n *\r\n * This module is used for both trigonometric geodesy (eg latlon-ellipsoidal-vincenty) and n-vector\r\n * geodesy (eg latlon-nvector-ellipsoidal), and also for UTM/MGRS mapping.\r\n *\r\n * @module latlon-ellipsoidal\r\n */\r\n\r\n\r\n/*\r\n * Ellipsoid parameters; exposed through static getter below.\r\n *\r\n * The only ellipsoid defined is WGS84, for use in utm/mgrs, vincenty, nvector.\r\n */\r\nconst ellipsoids = {\r\n    WGS84: { a: 6378137, b: 6356752.314245, f: 1/298.257223563 },\r\n};\r\n\r\n\r\n/*\r\n * Datums; exposed through static getter below.\r\n *\r\n * The only datum defined is WGS84, for use in utm/mgrs, vincenty, nvector.\r\n */\r\nconst datums = {\r\n    WGS84: { ellipsoid: ellipsoids.WGS84 },\r\n};\r\n\r\n\r\n// freeze static properties\r\nObject.freeze(ellipsoids.WGS84);\r\nObject.freeze(datums.WGS84);\r\n\r\n\r\n/* LatLonEllipsoidal - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\r\n\r\n\r\n/**\r\n * Latitude/longitude points on an ellipsoidal model earth, with ellipsoid parameters and methods\r\n * for converting points to/from cartesian (ECEF) coordinates.\r\n *\r\n * This is the core class, which will usually be used via LatLonEllipsoidal_Datum or\r\n * LatLonEllipsoidal_ReferenceFrame.\r\n */\r\nclass LatLonEllipsoidal {\r\n\r\n    /**\r\n     * Creates a geodetic latitude/longitude point on a (WGS84) ellipsoidal model earth.\r\n     *\r\n     * @param  {number} lat - Latitude (in degrees).\r\n     * @param  {number} lon - Longitude (in degrees).\r\n     * @param  {number} [height=0] - Height above ellipsoid in metres.\r\n     * @throws {TypeError} Invalid lat/lon/height.\r\n     *\r\n     * @example\r\n     *   import LatLon from '/js/geodesy/latlon-ellipsoidal.js';\r\n     *   const p = new LatLon(51.47788, -0.00147, 17);\r\n     */\r\n    constructor(lat, lon, height=0) {\r\n        if (isNaN(lat)) throw new TypeError(`invalid lat ‘${lat}’`);\r\n        if (isNaN(lon)) throw new TypeError(`invalid lon ‘${lon}’`);\r\n        if (isNaN(height)) throw new TypeError(`invalid height ‘${height}’`);\r\n\r\n        this._lat = Dms.wrap90(Number(lat));\r\n        this._lon = Dms.wrap180(Number(lon));\r\n        this._height = Number(height);\r\n    }\r\n\r\n\r\n    /**\r\n     * Latitude in degrees north from equator (including aliases lat, latitude): can be set as\r\n     * numeric or hexagesimal (deg-min-sec); returned as numeric.\r\n     */\r\n    get lat()       { return this._lat; }\r\n    get latitude()  { return this._lat; }\r\n    set lat(lat) {\r\n        this._lat = isNaN(lat) ? Dms.wrap90(Dms.parse(lat)) : Dms.wrap90(Number(lat));\r\n        if (isNaN(this._lat)) throw new TypeError(`invalid lat ‘${lat}’`);\r\n    }\r\n    set latitude(lat) {\r\n        this._lat = isNaN(lat) ? Dms.wrap90(Dms.parse(lat)) : Dms.wrap90(Number(lat));\r\n        if (isNaN(this._lat)) throw new TypeError(`invalid latitude ‘${lat}’`);\r\n    }\r\n\r\n    /**\r\n     * Longitude in degrees east from international reference meridian (including aliases lon, lng,\r\n     * longitude): can be set as numeric or hexagesimal (deg-min-sec); returned as numeric.\r\n     */\r\n    get lon()       { return this._lon; }\r\n    get lng()       { return this._lon; }\r\n    get longitude() { return this._lon; }\r\n    set lon(lon) {\r\n        this._lon = isNaN(lon) ? Dms.wrap180(Dms.parse(lon)) : Dms.wrap180(Number(lon));\r\n        if (isNaN(this._lon)) throw new TypeError(`invalid lon ‘${lon}’`);\r\n    }\r\n    set lng(lon) {\r\n        this._lon = isNaN(lon) ? Dms.wrap180(Dms.parse(lon)) : Dms.wrap180(Number(lon));\r\n        if (isNaN(this._lon)) throw new TypeError(`invalid lng ‘${lon}’`);\r\n    }\r\n    set longitude(lon) {\r\n        this._lon = isNaN(lon) ? Dms.wrap180(Dms.parse(lon)) : Dms.wrap180(Number(lon));\r\n        if (isNaN(this._lon)) throw new TypeError(`invalid longitude ‘${lon}’`);\r\n    }\r\n\r\n    /**\r\n     * Height in metres above ellipsoid.\r\n     */\r\n    get height()       { return this._height; }\r\n    set height(height) { this._height = Number(height); if (isNaN(this._height)) throw new TypeError(`invalid height ‘${height}’`); }\r\n\r\n\r\n    /**\r\n     * Datum.\r\n     *\r\n     * Note this is replicated within LatLonEllipsoidal in order that a LatLonEllipsoidal object can\r\n     * be monkey-patched to look like a LatLonEllipsoidal_Datum, for Vincenty calculations on\r\n     * different ellipsoids.\r\n     *\r\n     * @private\r\n     */\r\n    get datum()      { return this._datum; }\r\n    set datum(datum) { this._datum = datum; }\r\n\r\n\r\n    /**\r\n     * Ellipsoids with their parameters; this module only defines WGS84 parameters a = 6378137, b =\r\n     * 6356752.314245, f = 1/298.257223563.\r\n     *\r\n     * @example\r\n     *   const a = LatLon.ellipsoids.WGS84.a; // 6378137\r\n     */\r\n    static get ellipsoids() {\r\n        return ellipsoids;\r\n    }\r\n\r\n    /**\r\n     * Datums; this module only defines WGS84 datum, hence no datum transformations.\r\n     *\r\n     * @example\r\n     *   const a = LatLon.datums.WGS84.ellipsoid.a; // 6377563.396\r\n     */\r\n    static get datums() {\r\n        return datums;\r\n    }\r\n\r\n\r\n    /**\r\n     * Parses a latitude/longitude point from a variety of formats.\r\n     *\r\n     * Latitude & longitude (in degrees) can be supplied as two separate parameters, as a single\r\n     * comma-separated lat/lon string, or as a single object with { lat, lon } or GeoJSON properties.\r\n     *\r\n     * The latitude/longitude values may be numeric or strings; they may be signed decimal or\r\n     * deg-min-sec (hexagesimal) suffixed by compass direction (NSEW); a variety of separators are\r\n     * accepted. Examples -3.62, '3 37 12W', '3°37′12″W'.\r\n     *\r\n     * Thousands/decimal separators must be comma/dot; use Dms.fromLocale to convert locale-specific\r\n     * thousands/decimal separators.\r\n     *\r\n     * @param   {number|string|Object} lat|latlon - Latitude (in degrees), or comma-separated lat/lon, or lat/lon object.\r\n     * @param   {number}               [lon]      - Longitude (in degrees).\r\n     * @param   {number}               [height=0] - Height above ellipsoid in metres.\r\n     * @returns {LatLon} Latitude/longitude point on WGS84 ellipsoidal model earth.\r\n     * @throws  {TypeError} Invalid coordinate.\r\n     *\r\n     * @example\r\n     *   const p1 = LatLon.parse(51.47788, -0.00147);              // numeric pair\r\n     *   const p2 = LatLon.parse('51°28′40″N, 000°00′05″W', 17);   // dms string + height\r\n     *   const p3 = LatLon.parse({ lat: 52.205, lon: 0.119 }, 17); // { lat, lon } object numeric + height\r\n     */\r\n    static parse(...args) {\r\n        if (args.length == 0) throw new TypeError('invalid (empty) point');\r\n\r\n        let lat=undefined, lon=undefined, height=undefined;\r\n\r\n        // single { lat, lon } object\r\n        if (typeof args[0]=='object' && (args.length==1 || !isNaN(parseFloat(args[1])))) {\r\n            const ll = args[0];\r\n            if (ll.type == 'Point' && Array.isArray(ll.coordinates)) { // GeoJSON\r\n                [ lon, lat, height ] = ll.coordinates;\r\n                height = height || 0;\r\n            } else { // regular { lat, lon } object\r\n                if (ll.latitude  != undefined) lat = ll.latitude;\r\n                if (ll.lat       != undefined) lat = ll.lat;\r\n                if (ll.longitude != undefined) lon = ll.longitude;\r\n                if (ll.lng       != undefined) lon = ll.lng;\r\n                if (ll.lon       != undefined) lon = ll.lon;\r\n                if (ll.height    != undefined) height = ll.height;\r\n                lat = Dms.wrap90(Dms.parse(lat));\r\n                lon = Dms.wrap180(Dms.parse(lon));\r\n            }\r\n            if (args[1] != undefined) height = args[1];\r\n            if (isNaN(lat) || isNaN(lon)) throw new TypeError(`invalid point ‘${JSON.stringify(args[0])}’`);\r\n        }\r\n\r\n        // single comma-separated lat/lon\r\n        if (typeof args[0] == 'string' && args[0].split(',').length == 2) {\r\n            [ lat, lon ] = args[0].split(',');\r\n            lat = Dms.wrap90(Dms.parse(lat));\r\n            lon = Dms.wrap180(Dms.parse(lon));\r\n            height = args[1] || 0;\r\n            if (isNaN(lat) || isNaN(lon)) throw new TypeError(`invalid point ‘${args[0]}’`);\r\n        }\r\n\r\n        // regular (lat, lon) arguments\r\n        if (lat==undefined && lon==undefined) {\r\n            [ lat, lon ] = args;\r\n            lat = Dms.wrap90(Dms.parse(lat));\r\n            lon = Dms.wrap180(Dms.parse(lon));\r\n            height = args[2] || 0;\r\n            if (isNaN(lat) || isNaN(lon)) throw new TypeError(`invalid point ‘${args.toString()}’`);\r\n        }\r\n\r\n        return new this(lat, lon, height); // 'new this' as may return subclassed types\r\n    }\r\n\r\n\r\n    /**\r\n     * Converts ‘this’ point from (geodetic) latitude/longitude coordinates to (geocentric)\r\n     * cartesian (x/y/z) coordinates.\r\n     *\r\n     * @returns {Cartesian} Cartesian point equivalent to lat/lon point, with x, y, z in metres from\r\n     *   earth centre.\r\n     */\r\n    toCartesian() {\r\n        // x = (ν+h)⋅cosφ⋅cosλ, y = (ν+h)⋅cosφ⋅sinλ, z = (ν⋅(1-e²)+h)⋅sinφ\r\n        // where ν = a/√(1−e²⋅sinφ⋅sinφ), e² = (a²-b²)/a² or (better conditioned) 2⋅f-f²\r\n        const ellipsoid = this.datum\r\n            ? this.datum.ellipsoid\r\n            : this.referenceFrame ? this.referenceFrame.ellipsoid : ellipsoids.WGS84;\r\n\r\n        const φ = this.lat.toRadians();\r\n        const λ = this.lon.toRadians();\r\n        const h = this.height;\r\n        const { a, f } = ellipsoid;\r\n\r\n        const sinφ = Math.sin(φ), cosφ = Math.cos(φ);\r\n        const sinλ = Math.sin(λ), cosλ = Math.cos(λ);\r\n\r\n        const eSq = 2*f - f*f;                      // 1st eccentricity squared ≡ (a²-b²)/a²\r\n        const ν = a / Math.sqrt(1 - eSq*sinφ*sinφ); // radius of curvature in prime vertical\r\n\r\n        const x = (ν+h) * cosφ * cosλ;\r\n        const y = (ν+h) * cosφ * sinλ;\r\n        const z = (ν*(1-eSq)+h) * sinφ;\r\n\r\n        return new Cartesian(x, y, z);\r\n    }\r\n\r\n\r\n    /**\r\n     * Checks if another point is equal to ‘this’ point.\r\n     *\r\n     * @param   {LatLon} point - Point to be compared against this point.\r\n     * @returns {bool} True if points have identical latitude, longitude, height, and datum/referenceFrame.\r\n     * @throws  {TypeError} Invalid point.\r\n     *\r\n     * @example\r\n     *   const p1 = new LatLon(52.205, 0.119);\r\n     *   const p2 = new LatLon(52.205, 0.119);\r\n     *   const equal = p1.equals(p2); // true\r\n     */\r\n    equals(point) {\r\n        if (!(point instanceof LatLonEllipsoidal)) throw new TypeError(`invalid point ‘${point}’`);\r\n\r\n        if (Math.abs(this.lat - point.lat) > Number.EPSILON) return false;\r\n        if (Math.abs(this.lon - point.lon) > Number.EPSILON) return false;\r\n        if (Math.abs(this.height - point.height) > Number.EPSILON) return false;\r\n        if (this.datum != point.datum) return false;\r\n        if (this.referenceFrame != point.referenceFrame) return false;\r\n        if (this.epoch != point.epoch) return false;\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    /**\r\n     * Returns a string representation of ‘this’ point, formatted as degrees, degrees+minutes, or\r\n     * degrees+minutes+seconds.\r\n     *\r\n     * @param   {string} [format=d] - Format point as 'd', 'dm', 'dms', or 'n' for signed numeric.\r\n     * @param   {number} [dp=4|2|0] - Number of decimal places to use: default 4 for d, 2 for dm, 0 for dms.\r\n     * @param   {number} [dpHeight=null] - Number of decimal places to use for height; default is no height display.\r\n     * @returns {string} Comma-separated formatted latitude/longitude.\r\n     * @throws  {RangeError} Invalid format.\r\n     *\r\n     * @example\r\n     *   const greenwich = new LatLon(51.47788, -0.00147, 46);\r\n     *   const d = greenwich.toString();                        // 51.4779°N, 000.0015°W\r\n     *   const dms = greenwich.toString('dms', 2);              // 51°28′40″N, 000°00′05″W\r\n     *   const [lat, lon] = greenwich.toString('n').split(','); // 51.4779, -0.0015\r\n     *   const dmsh = greenwich.toString('dms', 0, 0);          // 51°28′40″N, 000°00′06″W +46m\r\n     */\r\n    toString(format='d', dp=undefined, dpHeight=null) {\r\n        // note: explicitly set dp to undefined for passing through to toLat/toLon\r\n        if (![ 'd', 'dm', 'dms', 'n' ].includes(format)) throw new RangeError(`invalid format ‘${format}’`);\r\n\r\n        const height = (this.height>=0 ? ' +' : ' ') + this.height.toFixed(dpHeight) + 'm';\r\n        if (format == 'n') { // signed numeric degrees\r\n            if (dp == undefined) dp = 4;\r\n            const lat = this.lat.toFixed(dp);\r\n            const lon = this.lon.toFixed(dp);\r\n            return `${lat}, ${lon}${dpHeight==null ? '' : height}`;\r\n        }\r\n\r\n        const lat = Dms.toLat(this.lat, format, dp);\r\n        const lon = Dms.toLon(this.lon, format, dp);\r\n\r\n        return `${lat}, ${lon}${dpHeight==null ? '' : height}`;\r\n    }\r\n\r\n}\r\n\r\n\r\n/* Cartesian  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\r\n\r\n\r\n/**\r\n * ECEF (earth-centered earth-fixed) geocentric cartesian coordinates.\r\n *\r\n * @extends Vector3d\r\n */\r\nclass Cartesian extends Vector3d {\r\n\r\n    /**\r\n     * Creates cartesian coordinate representing ECEF (earth-centric earth-fixed) point.\r\n     *\r\n     * @param {number} x - X coordinate in metres (=> 0°N,0°E).\r\n     * @param {number} y - Y coordinate in metres (=> 0°N,90°E).\r\n     * @param {number} z - Z coordinate in metres (=> 90°N).\r\n     *\r\n     * @example\r\n     *   import { Cartesian } from '/js/geodesy/latlon-ellipsoidal.js';\r\n     *   const coord = new Cartesian(3980581.210, -111.159, 4966824.522);\r\n     */\r\n    constructor(x, y, z) {\r\n        super(x, y, z); // arguably redundant constructor, but specifies units & axes\r\n    }\r\n\r\n\r\n    /**\r\n     * Converts ‘this’ (geocentric) cartesian (x/y/z) coordinate to (geodetic) latitude/longitude\r\n     * point on specified ellipsoid.\r\n     *\r\n     * Uses Bowring’s (1985) formulation for μm precision in concise form; ‘The accuracy of geodetic\r\n     * latitude and height equations’, B R Bowring, Survey Review vol 28, 218, Oct 1985.\r\n     *\r\n     * @param   {LatLon.ellipsoids} [ellipsoid=WGS84] - Ellipsoid to use when converting point.\r\n     * @returns {LatLon} Latitude/longitude point defined by cartesian coordinates, on given ellipsoid.\r\n     * @throws  {TypeError} Invalid ellipsoid.\r\n     *\r\n     * @example\r\n     *   const c = new Cartesian(4027893.924, 307041.993, 4919474.294);\r\n     *   const p = c.toLatLon(); // 50.7978°N, 004.3592°E\r\n     */\r\n    toLatLon(ellipsoid=ellipsoids.WGS84) {\r\n        // note ellipsoid is available as a parameter for when toLatLon gets subclassed to\r\n        // Ellipsoidal_Datum / Ellipsoidal_Referenceframe.\r\n        if (!ellipsoid || !ellipsoid.a) throw new TypeError(`invalid ellipsoid ‘${ellipsoid}’`);\r\n\r\n        const { x, y, z } = this;\r\n        const { a, b, f } = ellipsoid;\r\n\r\n        const e2 = 2*f - f*f;           // 1st eccentricity squared ≡ (a²−b²)/a²\r\n        const ε2 = e2 / (1-e2);         // 2nd eccentricity squared ≡ (a²−b²)/b²\r\n        const p = Math.sqrt(x*x + y*y); // distance from minor axis\r\n        const R = Math.sqrt(p*p + z*z); // polar radius\r\n\r\n        // parametric latitude (Bowring eqn.17, replacing tanβ = z·a / p·b)\r\n        const tanβ = (b*z)/(a*p) * (1+ε2*b/R);\r\n        const sinβ = tanβ / Math.sqrt(1+tanβ*tanβ);\r\n        const cosβ = sinβ / tanβ;\r\n\r\n        // geodetic latitude (Bowring eqn.18: tanφ = z+ε²⋅b⋅sin³β / p−e²⋅cos³β)\r\n        const φ = isNaN(cosβ) ? 0 : Math.atan2(z + ε2*b*sinβ*sinβ*sinβ, p - e2*a*cosβ*cosβ*cosβ);\r\n\r\n        // longitude\r\n        const λ = Math.atan2(y, x);\r\n\r\n        // height above ellipsoid (Bowring eqn.7)\r\n        const sinφ = Math.sin(φ), cosφ = Math.cos(φ);\r\n        const ν = a / Math.sqrt(1-e2*sinφ*sinφ); // length of the normal terminated by the minor axis\r\n        const h = p*cosφ + z*sinφ - (a*a/ν);\r\n\r\n        const point = new LatLonEllipsoidal(φ.toDegrees(), λ.toDegrees(), h);\r\n\r\n        return point;\r\n    }\r\n\r\n\r\n    /**\r\n     * Returns a string representation of ‘this’ cartesian point.\r\n     *\r\n     * @param   {number} [dp=0] - Number of decimal places to use.\r\n     * @returns {string} Comma-separated latitude/longitude.\r\n     */\r\n    toString(dp=0) {\r\n        const x = this.x.toFixed(dp), y = this.y.toFixed(dp), z = this.z.toFixed(dp);\r\n        return `[${x},${y},${z}]`;\r\n    }\r\n\r\n}\r\n\r\n\r\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\r\n\r\nexport { LatLonEllipsoidal as default, Cartesian, Vector3d, Dms };\r\n","/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\r\n/* Geodesy tools for conversions between (historical) datums          (c) Chris Veness 2005-2019  */\r\n/*                                                                                   MIT Licence  */\r\n/* www.movable-type.co.uk/scripts/latlong-convert-coords.html                                     */\r\n/* www.movable-type.co.uk/scripts/geodesy-library.html#latlon-ellipsoidal-datum                  */\r\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\r\n\r\nimport LatLonEllipsoidal, { Cartesian, Dms } from './latlon-ellipsoidal.js';\r\n\r\n\r\n/**\r\n * Historical geodetic datums: a latitude/longitude point defines a geographic location on or\r\n * above/below the  earth’s surface, measured in degrees from the equator & the International\r\n * Reference Meridian and metres above the ellipsoid, and based on a given datum. The datum is\r\n * based on a reference ellipsoid and tied to geodetic survey reference points.\r\n *\r\n * Modern geodesy is generally based on the WGS84 datum (as used for instance by GPS systems), but\r\n * previously various reference ellipsoids and datum references were used.\r\n *\r\n * This module extends the core latlon-ellipsoidal module to include ellipsoid parameters and datum\r\n * transformation parameters, and methods for converting between different (generally historical)\r\n * datums.\r\n *\r\n * It can be used for UK Ordnance Survey mapping (OS National Grid References are still based on the\r\n * otherwise historical OSGB36 datum), as well as for historical purposes.\r\n *\r\n * q.v. Ordnance Survey ‘A guide to coordinate systems in Great Britain’ Section 6,\r\n * www.ordnancesurvey.co.uk/docs/support/guide-coordinate-systems-great-britain.pdf, and also\r\n * www.ordnancesurvey.co.uk/blog/2014/12/2.\r\n *\r\n * @module latlon-ellipsoidal-datum\r\n */\r\n\r\n\r\n/*\r\n * Ellipsoid parameters; exposed through static getter below.\r\n */\r\nconst ellipsoids = {\r\n    WGS84:         { a: 6378137,     b: 6356752.314245, f: 1/298.257223563 },\r\n    Airy1830:      { a: 6377563.396, b: 6356256.909,    f: 1/299.3249646   },\r\n    AiryModified:  { a: 6377340.189, b: 6356034.448,    f: 1/299.3249646   },\r\n    Bessel1841:    { a: 6377397.155, b: 6356078.962818, f: 1/299.1528128   },\r\n    Clarke1866:    { a: 6378206.4,   b: 6356583.8,      f: 1/294.978698214 },\r\n    Clarke1880IGN: { a: 6378249.2,   b: 6356515.0,      f: 1/293.466021294 },\r\n    GRS80:         { a: 6378137,     b: 6356752.314140, f: 1/298.257222101 },\r\n    Intl1924:      { a: 6378388,     b: 6356911.946,    f: 1/297           }, // aka Hayford\r\n    WGS72:         { a: 6378135,     b: 6356750.5,      f: 1/298.26        },\r\n};\r\n\r\n\r\n/*\r\n * Datums; exposed through static getter below.\r\n */\r\nconst datums = {\r\n    // transforms: t in metres, s in ppm, r in arcseconds              tx       ty        tz       s        rx        ry        rz\r\n    ED50:       { ellipsoid: ellipsoids.Intl1924,      transform: [   89.5,    93.8,    123.1,    -1.2,     0.0,      0.0,      0.156    ] }, // epsg.io/1311\r\n    ETRS89:     { ellipsoid: ellipsoids.GRS80,         transform: [    0,       0,        0,       0,       0,        0,        0        ] }, // epsg.io/1149; @ 1-metre level\r\n    Irl1975:    { ellipsoid: ellipsoids.AiryModified,  transform: [ -482.530, 130.596, -564.557,  -8.150,   1.042,    0.214,    0.631    ] }, // epsg.io/1954\r\n    NAD27:      { ellipsoid: ellipsoids.Clarke1866,    transform: [    8,    -160,     -176,       0,       0,        0,        0        ] },\r\n    NAD83:      { ellipsoid: ellipsoids.GRS80,         transform: [    0.9956, -1.9103,  -0.5215, -0.00062, 0.025915, 0.009426, 0.011599 ] },\r\n    NTF:        { ellipsoid: ellipsoids.Clarke1880IGN, transform: [  168,      60,     -320,       0,       0,        0,        0        ] },\r\n    OSGB36:     { ellipsoid: ellipsoids.Airy1830,      transform: [ -446.448, 125.157, -542.060,  20.4894, -0.1502,  -0.2470,  -0.8421   ] }, // epsg.io/1314\r\n    Potsdam:    { ellipsoid: ellipsoids.Bessel1841,    transform: [ -582,    -105,     -414,      -8.3,     1.04,     0.35,    -3.08     ] },\r\n    TokyoJapan: { ellipsoid: ellipsoids.Bessel1841,    transform: [  148,    -507,     -685,       0,       0,        0,        0        ] },\r\n    WGS72:      { ellipsoid: ellipsoids.WGS72,         transform: [    0,       0,       -4.5,    -0.22,    0,        0,        0.554    ] },\r\n    WGS84:      { ellipsoid: ellipsoids.WGS84,         transform: [    0.0,     0.0,      0.0,     0.0,     0.0,      0.0,      0.0      ] },\r\n};\r\n/* sources:\r\n * - ED50:       www.gov.uk/guidance/oil-and-gas-petroleum-operations-notices#pon-4\r\n * - Irl1975:    www.osi.ie/wp-content/uploads/2015/05/transformations_booklet.pdf\r\n * - NAD27:      en.wikipedia.org/wiki/Helmert_transformation\r\n * - NAD83:      www.uvm.edu/giv/resources/WGS84_NAD83.pdf [strictly, WGS84(G1150) -> NAD83(CORS96) @ epoch 1997.0]\r\n *               (note NAD83(1986) ≡ WGS84(Original); confluence.qps.nl/pages/viewpage.action?pageId=29855173)\r\n * - NTF:        Nouvelle Triangulation Francaise geodesie.ign.fr/contenu/fichiers/Changement_systeme_geodesique.pdf\r\n * - OSGB36:     www.ordnancesurvey.co.uk/docs/support/guide-coordinate-systems-great-britain.pdf\r\n * - Potsdam:    kartoweb.itc.nl/geometrics/Coordinate%20transformations/coordtrans.html\r\n * - TokyoJapan: www.geocachingtoolbox.com?page=datumEllipsoidDetails\r\n * - WGS72:      www.icao.int/safety/pbn/documentation/eurocontrol/eurocontrol wgs 84 implementation manual.pdf\r\n *\r\n * more transform parameters are available from earth-info.nga.mil/GandG/coordsys/datums/NATO_DT.pdf,\r\n * www.fieldenmaps.info/cconv/web/cconv_params.js\r\n */\r\n/* note:\r\n * - ETRS89 reference frames are coincident with WGS-84 at epoch 1989.0 (ie null transform) at the one metre level.\r\n */\r\n\r\n\r\n// freeze static properties\r\nObject.keys(ellipsoids).forEach(e => Object.freeze(ellipsoids[e]));\r\nObject.keys(datums).forEach(d => { Object.freeze(datums[d]); Object.freeze(datums[d].transform); });\r\n\r\n\r\n/* LatLon - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\r\n\r\n\r\n/**\r\n * Latitude/longitude points on an ellipsoidal model earth, with ellipsoid parameters and methods\r\n * for converting between datums and to geocentric (ECEF) cartesian coordinates.\r\n *\r\n * @extends LatLonEllipsoidal\r\n */\r\nclass LatLonEllipsoidal_Datum extends LatLonEllipsoidal {\r\n\r\n    /**\r\n     * Creates a geodetic latitude/longitude point on an ellipsoidal model earth using given datum.\r\n     *\r\n     * @param {number} lat - Latitude (in degrees).\r\n     * @param {number} lon - Longitude (in degrees).\r\n     * @param {number} [height=0] - Height above ellipsoid in metres.\r\n     * @param {LatLon.datums} datum - Datum this point is defined within.\r\n     *\r\n     * @example\r\n     *   import LatLon from '/js/geodesy/latlon-ellipsoidal-datum.js';\r\n     *   const p = new LatLon(53.3444, -6.2577, 17, LatLon.datums.Irl1975);\r\n     */\r\n    constructor(lat, lon, height=0, datum=datums.WGS84) {\r\n        if (!datum || datum.ellipsoid==undefined) throw new TypeError(`unrecognised datum ‘${datum}’`);\r\n\r\n        super(lat, lon, height);\r\n\r\n        this._datum = datum;\r\n    }\r\n\r\n\r\n    /**\r\n     * Datum this point is defined within.\r\n     */\r\n    get datum() {\r\n        return this._datum;\r\n    }\r\n\r\n\r\n    /**\r\n     * Ellipsoids with their parameters; semi-major axis (a), semi-minor axis (b), and flattening (f).\r\n     *\r\n     * Flattening f = (a−b)/a; at least one of these parameters is derived from defining constants.\r\n     *\r\n     * @example\r\n     *   const a = LatLon.ellipsoids.Airy1830.a; // 6377563.396\r\n     */\r\n    static get ellipsoids() {\r\n        return ellipsoids;\r\n    }\r\n\r\n\r\n    /**\r\n     * Datums; with associated ellipsoid, and Helmert transform parameters to convert from WGS-84\r\n     * into given datum.\r\n     *\r\n     * Note that precision of various datums will vary, and WGS-84 (original) is not defined to be\r\n     * accurate to better than ±1 metre. No transformation should be assumed to be accurate to\r\n     * better than a metre, for many datums somewhat less.\r\n     *\r\n     * This is a small sample of commoner datums from a large set of historical datums. I will add\r\n     * new datums on request.\r\n     *\r\n     * @example\r\n     *   const a = LatLon.datums.OSGB36.ellipsoid.a;                    // 6377563.396\r\n     *   const tx = LatLon.datums.OSGB36.transform;                     // [ tx, ty, tz, s, rx, ry, rz ]\r\n     *   const availableDatums = Object.keys(LatLon.datums).join(', '); // ED50, Irl1975, NAD27, ...\r\n     */\r\n    static get datums() {\r\n        return datums;\r\n    }\r\n\r\n\r\n    // note instance datum getter/setters are in LatLonEllipsoidal\r\n\r\n\r\n    /**\r\n     * Parses a latitude/longitude point from a variety of formats.\r\n     *\r\n     * Latitude & longitude (in degrees) can be supplied as two separate parameters, as a single\r\n     * comma-separated lat/lon string, or as a single object with { lat, lon } or GeoJSON properties.\r\n     *\r\n     * The latitude/longitude values may be numeric or strings; they may be signed decimal or\r\n     * deg-min-sec (hexagesimal) suffixed by compass direction (NSEW); a variety of separators are\r\n     * accepted. Examples -3.62, '3 37 12W', '3°37′12″W'.\r\n     *\r\n     * Thousands/decimal separators must be comma/dot; use Dms.fromLocale to convert locale-specific\r\n     * thousands/decimal separators.\r\n     *\r\n     * @param   {number|string|Object} lat|latlon - Geodetic Latitude (in degrees) or comma-separated lat/lon or lat/lon object.\r\n     * @param   {number}               [lon] - Longitude in degrees.\r\n     * @param   {number}               [height=0] - Height above ellipsoid in metres.\r\n     * @param   {LatLon.datums}        [datum=WGS84] - Datum this point is defined within.\r\n     * @returns {LatLon} Latitude/longitude point on ellipsoidal model earth using given datum.\r\n     * @throws  {TypeError} Unrecognised datum.\r\n     *\r\n     * @example\r\n     *   const p = LatLon.parse('51.47736, 0.0000', 0, LatLon.datums.OSGB36);\r\n     */\r\n    static parse(...args) {\r\n        let datum = datums.WGS84;\r\n\r\n        // if the last argument is a datum, use that, otherwise use default WGS-84\r\n        if (args.length==4 || (args.length==3 && typeof args[2] == 'object')) datum = args.pop();\r\n\r\n        if (!datum || datum.ellipsoid==undefined) throw new TypeError(`unrecognised datum ‘${datum}’`);\r\n\r\n        const point = super.parse(...args);\r\n\r\n        point._datum = datum;\r\n\r\n        return point;\r\n    }\r\n\r\n\r\n    /**\r\n     * Converts ‘this’ lat/lon coordinate to new coordinate system.\r\n     *\r\n     * @param   {LatLon.datums} toDatum - Datum this coordinate is to be converted to.\r\n     * @returns {LatLon} This point converted to new datum.\r\n     * @throws  {TypeError} Unrecognised datum.\r\n     *\r\n     * @example\r\n     *   const pWGS84 = new LatLon(51.47788, -0.00147, 0, LatLon.datums.WGS84);\r\n     *   const pOSGB = pWGS84.convertDatum(LatLon.datums.OSGB36); // 51.4773°N, 000.0001°E\r\n     */\r\n    convertDatum(toDatum) {\r\n        if (!toDatum || toDatum.ellipsoid==undefined) throw new TypeError(`unrecognised datum ‘${toDatum}’`);\r\n\r\n        const oldCartesian = this.toCartesian();                 // convert geodetic to cartesian\r\n        const newCartesian = oldCartesian.convertDatum(toDatum); // convert datum\r\n        const newLatLon = newCartesian.toLatLon();               // convert cartesian back to geodetic\r\n\r\n        return newLatLon;\r\n    }\r\n\r\n\r\n    /**\r\n     * Converts ‘this’ point from (geodetic) latitude/longitude coordinates to (geocentric) cartesian\r\n     * (x/y/z) coordinates, based on the same datum.\r\n     *\r\n     * Shadow of LatLonEllipsoidal.toCartesian(), returning Cartesian augmented with\r\n     * LatLonEllipsoidal_Datum methods/properties.\r\n     *\r\n     * @returns {Cartesian} Cartesian point equivalent to lat/lon point, with x, y, z in metres from\r\n     *   earth centre, augmented with reference frame conversion methods and properties.\r\n     */\r\n    toCartesian() {\r\n        const cartesian = super.toCartesian();\r\n        const cartesianDatum = new Cartesian_Datum(cartesian.x, cartesian.y, cartesian.z, this.datum);\r\n        return cartesianDatum;\r\n    }\r\n\r\n}\r\n\r\n\r\n/* Cartesian  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\r\n\r\n\r\n/**\r\n * Augments Cartesian with datum the cooordinate is based on, and methods to convert between datums\r\n * (using Helmert 7-parameter transforms) and to convert cartesian to geodetic latitude/longitude\r\n * point.\r\n *\r\n * @extends Cartesian\r\n */\r\nclass Cartesian_Datum extends Cartesian {\r\n\r\n    /**\r\n     * Creates cartesian coordinate representing ECEF (earth-centric earth-fixed) point, on a given\r\n     * datum. The datum will identify the primary meridian (for the x-coordinate), and is also\r\n     * useful in transforming to/from geodetic (lat/lon) coordinates.\r\n     *\r\n     * @param  {number} x - X coordinate in metres (=> 0°N,0°E).\r\n     * @param  {number} y - Y coordinate in metres (=> 0°N,90°E).\r\n     * @param  {number} z - Z coordinate in metres (=> 90°N).\r\n     * @param  {LatLon.datums} [datum] - Datum this coordinate is defined within.\r\n     * @throws {TypeError} Unrecognised datum.\r\n     *\r\n     * @example\r\n     *   import { Cartesian } from '/js/geodesy/latlon-ellipsoidal-datum.js';\r\n     *   const coord = new Cartesian(3980581.210, -111.159, 4966824.522);\r\n     */\r\n    constructor(x, y, z, datum=undefined) {\r\n        if (datum && datum.ellipsoid==undefined) throw new TypeError(`unrecognised datum ‘${datum}’`);\r\n\r\n        super(x, y, z);\r\n\r\n        if (datum) this._datum = datum;\r\n    }\r\n\r\n\r\n    /**\r\n     * Datum this point is defined within.\r\n     */\r\n    get datum() {\r\n        return this._datum;\r\n    }\r\n    set datum(datum) {\r\n        if (!datum || datum.ellipsoid==undefined) throw new TypeError(`unrecognised datum ‘${datum}’`);\r\n        this._datum = datum;\r\n    }\r\n\r\n\r\n    /**\r\n     * Converts ‘this’ (geocentric) cartesian (x/y/z) coordinate to (geodetic) latitude/longitude\r\n     * point (based on the same datum, or WGS84 if unset).\r\n     *\r\n     * Shadow of Cartesian.toLatLon(), returning LatLon augmented with LatLonEllipsoidal_Datum\r\n     * methods convertDatum, toCartesian, etc.\r\n     *\r\n     * @returns {LatLon} Latitude/longitude point defined by cartesian coordinates.\r\n     * @throws  {TypeError} Unrecognised datum\r\n     *\r\n     * @example\r\n     *   const c = new Cartesian(4027893.924, 307041.993, 4919474.294);\r\n     *   const p = c.toLatLon(); // 50.7978°N, 004.3592°E\r\n     */\r\n    toLatLon(deprecatedDatum=undefined) {\r\n        if (deprecatedDatum) {\r\n            console.info('datum parameter to Cartesian_Datum.toLatLon is deprecated: set datum before calling toLatLon()');\r\n            this.datum = deprecatedDatum;\r\n        }\r\n        const datum = this.datum || datums.WGS84;\r\n        if (!datum || datum.ellipsoid==undefined) throw new TypeError(`unrecognised datum ‘${datum}’`);\r\n\r\n        const latLon = super.toLatLon(datum.ellipsoid); // TODO: what if datum is not geocentric?\r\n        const point = new LatLonEllipsoidal_Datum(latLon.lat, latLon.lon, latLon.height, this.datum);\r\n        return point;\r\n    }\r\n\r\n\r\n    /**\r\n     * Converts ‘this’ cartesian coordinate to new datum using Helmert 7-parameter transformation.\r\n     *\r\n     * @param   {LatLon.datums} toDatum - Datum this coordinate is to be converted to.\r\n     * @returns {Cartesian} This point converted to new datum.\r\n     * @throws  {Error} Undefined datum.\r\n     *\r\n     * @example\r\n     *   const c = new Cartesian(3980574.247, -102.127, 4966830.065, LatLon.datums.OSGB36);\r\n     *   c.convertDatum(LatLon.datums.Irl1975); // [??,??,??]\r\n     */\r\n    convertDatum(toDatum) {\r\n        // TODO: what if datum is not geocentric?\r\n        if (!toDatum || toDatum.ellipsoid == undefined) throw new TypeError(`unrecognised datum ‘${toDatum}’`);\r\n        if (!this.datum) throw new TypeError('cartesian coordinate has no datum');\r\n\r\n        let oldCartesian = null;\r\n        let transform = null;\r\n\r\n        if (this.datum == undefined || this.datum == datums.WGS84) {\r\n            // converting from WGS 84\r\n            oldCartesian = this;\r\n            transform = toDatum.transform;\r\n        }\r\n        if (toDatum == datums.WGS84) {\r\n            // converting to WGS 84; use inverse transform\r\n            oldCartesian = this;\r\n            transform = this.datum.transform.map(p => -p);\r\n        }\r\n        if (transform == null) {\r\n            // neither this.datum nor toDatum are WGS84: convert this to WGS84 first\r\n            oldCartesian = this.convertDatum(datums.WGS84);\r\n            transform = toDatum.transform;\r\n        }\r\n\r\n        const newCartesian = oldCartesian.applyTransform(transform);\r\n        newCartesian.datum = toDatum;\r\n\r\n        return newCartesian;\r\n    }\r\n\r\n\r\n    /**\r\n     * Applies Helmert 7-parameter transformation to ‘this’ coordinate using transform parameters t.\r\n     *\r\n     * This is used in converting datums (geodetic->cartesian, apply transform, cartesian->geodetic).\r\n     *\r\n     * @private\r\n     * @param   {number[]} t - Transformation to apply to this coordinate.\r\n     * @returns {Cartesian} Transformed point.\r\n     */\r\n    applyTransform(t)   {\r\n        // this point\r\n        const { x: x1, y: y1, z: z1 } = this;\r\n\r\n        // transform parameters\r\n        const tx = t[0];                    // x-shift in metres\r\n        const ty = t[1];                    // y-shift in metres\r\n        const tz = t[2];                    // z-shift in metres\r\n        const s  = t[3]/1e6 + 1;            // scale: normalise parts-per-million to (s+1)\r\n        const rx = (t[4]/3600).toRadians(); // x-rotation: normalise arcseconds to radians\r\n        const ry = (t[5]/3600).toRadians(); // y-rotation: normalise arcseconds to radians\r\n        const rz = (t[6]/3600).toRadians(); // z-rotation: normalise arcseconds to radians\r\n\r\n        // apply transform\r\n        const x2 = tx + x1*s  - y1*rz + z1*ry;\r\n        const y2 = ty + x1*rz + y1*s  - z1*rx;\r\n        const z2 = tz - x1*ry + y1*rx + z1*s;\r\n\r\n        return new Cartesian_Datum(x2, y2, z2);\r\n    }\r\n}\r\n\r\n\r\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\r\n\r\nexport { LatLonEllipsoidal_Datum as default, Cartesian_Datum as Cartesian, datums, Dms };\r\n","/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\r\n/* Ordnance Survey Grid Reference functions                           (c) Chris Veness 2005-2020  */\r\n/*                                                                                   MIT Licence  */\r\n/* www.movable-type.co.uk/scripts/latlong-gridref.html                                            */\r\n/* www.movable-type.co.uk/scripts/geodesy-library.html#osgridref                                  */\r\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\r\n\r\nimport LatLonEllipsoidal, { Dms } from './latlon-ellipsoidal-datum.js';\r\n\r\n/**\r\n * Ordnance Survey OSGB grid references provide geocoordinate references for UK mapping purposes.\r\n *\r\n * Formulation implemented here due to Thomas, Redfearn, etc is as published by OS, but is inferior\r\n * to Krüger as used by e.g. Karney 2011.\r\n *\r\n * www.ordnancesurvey.co.uk/documents/resources/guide-coordinate-systems-great-britain.pdf.\r\n *\r\n * Note OSGB grid references cover Great Britain only; Ireland and the Channel Islands have their\r\n * own references.\r\n *\r\n * Note that these formulae are based on ellipsoidal calculations, and according to the OS are\r\n * accurate to about 4–5 metres – for greater accuracy, a geoid-based transformation (OSTN15) must\r\n * be used.\r\n */\r\n\r\n/*\r\n * Converted 2015 to work with WGS84 by default, OSGB36 as option;\r\n * www.ordnancesurvey.co.uk/blog/2014/12/confirmation-on-changes-to-latitude-and-longitude\r\n */\r\n\r\n\r\n/* OsGridRef  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\r\n\r\n\r\n/**\r\n * OS grid references with methods to parse and convert them to latitude/longitude points.\r\n *\r\n * @module osgridref\r\n */\r\nexport class OsGridRef {\r\n\r\n    /**\r\n     * Creates an OsGridRef object.\r\n     *\r\n     * @param {number} easting - Easting in metres from OS false origin.\r\n     * @param {number} northing - Northing in metres from OS false origin.\r\n     *\r\n     * @example\r\n     *   import OsGridRef from '/js/geodesy/osgridref.js';\r\n     *   const gridref = new OsGridRef(651409, 313177);\r\n     */\r\n    constructor(easting, northing) {\r\n        this.easting = Number(easting);\r\n        this.northing = Number(northing);\r\n\r\n        if (isNaN(easting)  || this.easting<0  || this.easting>700e3) throw new RangeError(`invalid easting ‘${easting}’`);\r\n        if (isNaN(northing) || this.northing<0 || this.northing>1300e3) throw new RangeError(`invalid northing ‘${northing}’`);\r\n    }\r\n\r\n\r\n    /**\r\n     * Converts ‘this’ Ordnance Survey grid reference easting/northing coordinate to latitude/longitude\r\n     * (SW corner of grid square).\r\n     *\r\n     * While OS grid references are based on OSGB-36, the Ordnance Survey have deprecated the use of\r\n     * OSGB-36 for latitude/longitude coordinates (in favour of WGS-84), hence this function returns\r\n     * WGS-84 by default, with OSGB-36 as an option. See www.ordnancesurvey.co.uk/blog/2014/12/2.\r\n     *\r\n     * Note formulation implemented here due to Thomas, Redfearn, etc is as published by OS, but is\r\n     * inferior to Krüger as used by e.g. Karney 2011.\r\n     *\r\n     * @param   {LatLon.datum} [datum=WGS84] - Datum to convert grid reference into.\r\n     * @returns {LatLon}       Latitude/longitude of supplied grid reference.\r\n     *\r\n     * @example\r\n     *   const gridref = new OsGridRef(651409.903, 313177.270);\r\n     *   const pWgs84 = gridref.toLatLon();                    // 52°39′28.723″N, 001°42′57.787″E\r\n     *   // to obtain (historical) OSGB36 lat/lon point:\r\n     *   const pOsgb = gridref.toLatLon(LatLon.datums.OSGB36); // 52°39′27.253″N, 001°43′04.518″E\r\n     */\r\n    toLatLon(datum=LatLonEllipsoidal.datums.WGS84) {\r\n        const { easting: E, northing: N } = this;\r\n\r\n        const a = 6377563.396, b = 6356256.909;             // Airy 1830 major & minor semi-axes\r\n        const F0 = 0.9996012717;                            // NatGrid scale factor on central meridian\r\n        const φ0 = (49).toRadians(), λ0 = (-2).toRadians(); // NatGrid true origin is 49°N,2°W\r\n        const N0 = -100e3, E0 = 400e3;                      // northing & easting of true origin, metres\r\n        const e2 = 1 - (b*b)/(a*a);                         // eccentricity squared\r\n        const n = (a-b)/(a+b), n2 = n*n, n3 = n*n*n;        // n, n², n³\r\n\r\n        let φ=φ0, M=0;\r\n        do {\r\n            φ = (N-N0-M)/(a*F0) + φ;\r\n\r\n            const Ma = (1 + n + (5/4)*n2 + (5/4)*n3) * (φ-φ0);\r\n            const Mb = (3*n + 3*n*n + (21/8)*n3) * Math.sin(φ-φ0) * Math.cos(φ+φ0);\r\n            const Mc = ((15/8)*n2 + (15/8)*n3) * Math.sin(2*(φ-φ0)) * Math.cos(2*(φ+φ0));\r\n            const Md = (35/24)*n3 * Math.sin(3*(φ-φ0)) * Math.cos(3*(φ+φ0));\r\n            M = b * F0 * (Ma - Mb + Mc - Md);                // meridional arc\r\n\r\n        } while (Math.abs(N-N0-M) >= 0.00001);  // ie until < 0.01mm\r\n\r\n        const cosφ = Math.cos(φ), sinφ = Math.sin(φ);\r\n        const ν = a*F0/Math.sqrt(1-e2*sinφ*sinφ);            // nu = transverse radius of curvature\r\n        const ρ = a*F0*(1-e2)/Math.pow(1-e2*sinφ*sinφ, 1.5); // rho = meridional radius of curvature\r\n        const η2 = ν/ρ-1;                                    // eta = ?\r\n\r\n        const tanφ = Math.tan(φ);\r\n        const tan2φ = tanφ*tanφ, tan4φ = tan2φ*tan2φ, tan6φ = tan4φ*tan2φ;\r\n        const secφ = 1/cosφ;\r\n        const ν3 = ν*ν*ν, ν5 = ν3*ν*ν, ν7 = ν5*ν*ν;\r\n        const VII = tanφ/(2*ρ*ν);\r\n        const VIII = tanφ/(24*ρ*ν3)*(5+3*tan2φ+η2-9*tan2φ*η2);\r\n        const IX = tanφ/(720*ρ*ν5)*(61+90*tan2φ+45*tan4φ);\r\n        const X = secφ/ν;\r\n        const XI = secφ/(6*ν3)*(ν/ρ+2*tan2φ);\r\n        const XII = secφ/(120*ν5)*(5+28*tan2φ+24*tan4φ);\r\n        const XIIA = secφ/(5040*ν7)*(61+662*tan2φ+1320*tan4φ+720*tan6φ);\r\n\r\n        const dE = (E-E0), dE2 = dE*dE, dE3 = dE2*dE, dE4 = dE2*dE2, dE5 = dE3*dE2, dE6 = dE4*dE2, dE7 = dE5*dE2;\r\n        φ = φ - VII*dE2 + VIII*dE4 - IX*dE6;\r\n        const λ = λ0 + X*dE - XI*dE3 + XII*dE5 - XIIA*dE7;\r\n\r\n        let point = new LatLon_OsGridRef(φ.toDegrees(), λ.toDegrees(), 0, LatLonEllipsoidal.datums.OSGB36);\r\n\r\n        if (datum != LatLonEllipsoidal.datums.OSGB36) {\r\n            // if point is required in datum other than OSGB36, convert it\r\n            point = point.convertDatum(datum);\r\n            // convertDatum() gives us a LatLon: convert to LatLon_OsGridRef which includes toOsGrid()\r\n            point = new LatLon_OsGridRef(point.lat, point.lon, point.height, point.datum);\r\n        }\r\n\r\n        return point;\r\n    }\r\n\r\n\r\n    /**\r\n     * Parses grid reference to OsGridRef object.\r\n     *\r\n     * Accepts standard grid references (eg 'SU 387 148'), with or without whitespace separators, from\r\n     * two-digit references up to 10-digit references (1m × 1m square), or fully numeric comma-separated\r\n     * references in metres (eg '438700,114800').\r\n     *\r\n     * @param   {string}    gridref - Standard format OS grid reference.\r\n     * @returns {OsGridRef} Numeric version of grid reference in metres from false origin (SW corner of\r\n     *   supplied grid square).\r\n     * @throws  {Error}     Invalid grid reference.\r\n     *\r\n     * @example\r\n     *   const grid = OsGridRef.parse('TG 51409 13177'); // grid: { easting: 651409, northing: 313177 }\r\n     */\r\n    static parse(gridref) {\r\n        gridref = String(gridref).trim();\r\n\r\n        // check for fully numeric comma-separated gridref format\r\n        let match = gridref.match(/^(\\d+),\\s*(\\d+)$/);\r\n        if (match) return new OsGridRef(match[1], match[2]);\r\n\r\n        // validate format\r\n        match = gridref.match(/^[HNST][ABCDEFGHJKLMNOPQRSTUVWXYZ]\\s*[0-9]+\\s*[0-9]+$/i);\r\n        if (!match) throw new Error(`invalid grid reference ‘${gridref}’`);\r\n\r\n        // get numeric values of letter references, mapping A->0, B->1, C->2, etc:\r\n        let l1 = gridref.toUpperCase().charCodeAt(0) - 'A'.charCodeAt(0); // 500km square\r\n        let l2 = gridref.toUpperCase().charCodeAt(1) - 'A'.charCodeAt(0); // 100km square\r\n        // shuffle down letters after 'I' since 'I' is not used in grid:\r\n        if (l1 > 7) l1--;\r\n        if (l2 > 7) l2--;\r\n\r\n        // convert grid letters into 100km-square indexes from false origin (grid square SV):\r\n        const e100km = ((l1 - 2) % 5) * 5 + (l2 % 5);\r\n        const n100km = (19 - Math.floor(l1 / 5) * 5) - Math.floor(l2 / 5);\r\n\r\n        // skip grid letters to get numeric (easting/northing) part of ref\r\n        let en = gridref.slice(2).trim().split(/\\s+/);\r\n        // if e/n not whitespace separated, split half way\r\n        if (en.length == 1) en = [ en[0].slice(0, en[0].length / 2), en[0].slice(en[0].length / 2) ];\r\n\r\n        // validation\r\n        if (en[0].length != en[1].length) throw new Error(`invalid grid reference ‘${gridref}’`);\r\n\r\n        // standardise to 10-digit refs (metres)\r\n        en[0] = en[0].padEnd(5, '0');\r\n        en[1] = en[1].padEnd(5, '0');\r\n\r\n        const e = e100km + en[0];\r\n        const n = n100km + en[1];\r\n\r\n        return new OsGridRef(e, n);\r\n    }\r\n\r\n\r\n    /**\r\n     * Converts ‘this’ numeric grid reference to standard OS grid reference.\r\n     *\r\n     * @param   {number} [digits=10] - Precision of returned grid reference (10 digits = metres);\r\n     *   digits=0 will return grid reference in numeric format.\r\n     * @returns {string} This grid reference in standard format.\r\n     *\r\n     * @example\r\n     *   const gridref = new OsGridRef(651409, 313177).toString(8); // 'TG 5140 1317'\r\n     *   const gridref = new OsGridRef(651409, 313177).toString(0); // '651409,313177'\r\n     */\r\n    toString(digits=10) {\r\n        if (![ 0,2,4,6,8,10,12,14,16 ].includes(Number(digits))) throw new RangeError(`invalid precision ‘${digits}’`); // eslint-disable-line comma-spacing\r\n\r\n        let { easting: e, northing: n } = this;\r\n\r\n        // use digits = 0 to return numeric format (in metres) - note northing may be >= 1e7\r\n        if (digits == 0) {\r\n            const format = { useGrouping: false,  minimumIntegerDigits: 6, maximumFractionDigits: 3 };\r\n            const ePad = e.toLocaleString('en', format);\r\n            const nPad = n.toLocaleString('en', format);\r\n            return `${ePad},${nPad}`;\r\n        }\r\n\r\n        // get the 100km-grid indices\r\n        const e100km = Math.floor(e / 100000), n100km = Math.floor(n / 100000);\r\n\r\n        // translate those into numeric equivalents of the grid letters\r\n        let l1 = (19 - n100km) - (19 - n100km) % 5 + Math.floor((e100km + 10) / 5);\r\n        let l2 = (19 - n100km) * 5 % 25 + e100km % 5;\r\n\r\n        // compensate for skipped 'I' and build grid letter-pairs\r\n        if (l1 > 7) l1++;\r\n        if (l2 > 7) l2++;\r\n        const letterPair = String.fromCharCode(l1 + 'A'.charCodeAt(0), l2 + 'A'.charCodeAt(0));\r\n\r\n        // strip 100km-grid indices from easting & northing, and reduce precision\r\n        e = Math.floor((e % 100000) / Math.pow(10, 5 - digits / 2));\r\n        n = Math.floor((n % 100000) / Math.pow(10, 5 - digits / 2));\r\n\r\n        // pad eastings & northings with leading zeros\r\n        e = e.toString().padStart(digits/2, '0');\r\n        n = n.toString().padStart(digits/2, '0');\r\n\r\n        return `${letterPair} ${e} ${n}`;\r\n    }\r\n\r\n}\r\n\r\n\r\n/* LatLon_OsGridRef - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\r\n\r\n\r\n/**\r\n * Extends LatLon class with method to convert LatLon point to OS grid reference.\r\n *\r\n * @extends LatLon\r\n */\r\nclass LatLon_OsGridRef extends LatLonEllipsoidal {\r\n\r\n    /**\r\n     * Converts latitude/longitude to Ordnance Survey grid reference easting/northing coordinate.\r\n     *\r\n     * @returns {OsGridRef} OS Grid Reference easting/northing.\r\n     *\r\n     * @example\r\n     *   const grid = new LatLon(52.65798, 1.71605).toOsGrid(); // TG 51409 13177\r\n     *   // for conversion of (historical) OSGB36 latitude/longitude point:\r\n     *   const grid = new LatLon(52.65798, 1.71605).toOsGrid(LatLon.datums.OSGB36);\r\n     */\r\n    toOsGrid() {\r\n        // if necessary convert to OSGB36 first\r\n        const point = this.datum == LatLonEllipsoidal.datums.OSGB36\r\n            ? this\r\n            : this.convertDatum(LatLonEllipsoidal.datums.OSGB36);\r\n\r\n        const φ = point.lat.toRadians();\r\n        const λ = point.lon.toRadians();\r\n\r\n        const a = 6377563.396, b = 6356256.909;              // Airy 1830 major & minor semi-axes\r\n        const F0 = 0.9996012717;                             // NatGrid scale factor on central meridian\r\n        const φ0 = (49).toRadians(), λ0 = (-2).toRadians();  // NatGrid true origin is 49°N,2°W\r\n        const N0 = -100000, E0 = 400000;                     // northing & easting of true origin, metres\r\n        const e2 = 1 - (b*b)/(a*a);                          // eccentricity squared\r\n        const n = (a-b)/(a+b), n2 = n*n, n3 = n*n*n;         // n, n², n³\r\n\r\n        const cosφ = Math.cos(φ), sinφ = Math.sin(φ);\r\n        const ν = a*F0/Math.sqrt(1-e2*sinφ*sinφ);            // nu = transverse radius of curvature\r\n        const ρ = a*F0*(1-e2)/Math.pow(1-e2*sinφ*sinφ, 1.5); // rho = meridional radius of curvature\r\n        const η2 = ν/ρ-1;                                    // eta = ?\r\n\r\n        const Ma = (1 + n + (5/4)*n2 + (5/4)*n3) * (φ-φ0);\r\n        const Mb = (3*n + 3*n*n + (21/8)*n3) * Math.sin(φ-φ0) * Math.cos(φ+φ0);\r\n        const Mc = ((15/8)*n2 + (15/8)*n3) * Math.sin(2*(φ-φ0)) * Math.cos(2*(φ+φ0));\r\n        const Md = (35/24)*n3 * Math.sin(3*(φ-φ0)) * Math.cos(3*(φ+φ0));\r\n        const M = b * F0 * (Ma - Mb + Mc - Md);              // meridional arc\r\n\r\n        const cos3φ = cosφ*cosφ*cosφ;\r\n        const cos5φ = cos3φ*cosφ*cosφ;\r\n        const tan2φ = Math.tan(φ)*Math.tan(φ);\r\n        const tan4φ = tan2φ*tan2φ;\r\n\r\n        const I = M + N0;\r\n        const II = (ν/2)*sinφ*cosφ;\r\n        const III = (ν/24)*sinφ*cos3φ*(5-tan2φ+9*η2);\r\n        const IIIA = (ν/720)*sinφ*cos5φ*(61-58*tan2φ+tan4φ);\r\n        const IV = ν*cosφ;\r\n        const V = (ν/6)*cos3φ*(ν/ρ-tan2φ);\r\n        const VI = (ν/120) * cos5φ * (5 - 18*tan2φ + tan4φ + 14*η2 - 58*tan2φ*η2);\r\n\r\n        const Δλ = λ-λ0;\r\n        const Δλ2 = Δλ*Δλ, Δλ3 = Δλ2*Δλ, Δλ4 = Δλ3*Δλ, Δλ5 = Δλ4*Δλ, Δλ6 = Δλ5*Δλ;\r\n\r\n        let N = I + II*Δλ2 + III*Δλ4 + IIIA*Δλ6;\r\n        let E = E0 + IV*Δλ + V*Δλ3 + VI*Δλ5;\r\n\r\n        N = Number(N.toFixed(3)); // round to mm precision\r\n        E = Number(E.toFixed(3));\r\n\r\n        try {\r\n            return new OsGridRef(E, N); // note: gets truncated to SW corner of 1m grid square\r\n        } catch (e) {\r\n            throw new Error(`${e.message} from (${point.lat.toFixed(6)},${point.lon.toFixed(6)}).toOsGrid()`);\r\n        }\r\n    }\r\n\r\n}\r\n\r\n\r\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\r\n\r\nexport { OsGridRef as default, LatLon_OsGridRef as LatLon, Dms };\r\n","// My Implemented Converter class to easily switch between lat-long and OSGB\r\n\r\nimport { datums } from \"./math/latlon-ellipsoidal-datum\"; // Grab the datum object to access Datum codes.\r\nimport { LatLon, OsGridRef } from \"./math/osgridref\"; // Grab LatLon and OsGridRef Classes\r\n\r\nclass CoordConverter {\r\n    // getOSGB_FromDec() - Get OSGB From Decimal\r\n    /*\r\n        @param lat : The Latitude\r\n        @param long : The Longitude\r\n        @param datum : [OPTIONAL] the Datum code, defaulted to null = WGS84\r\n\r\n        @return : easting and northing from OS Grid Ref\r\n    */\r\n    getOSGB_FromDec(lat, long, datum = null) {\r\n        // If no datum supplied, the datum will default to WGS84\r\n        if (datum == null) {\r\n            datum = datums.WGS84;\r\n        }\r\n\r\n        const latlong = new LatLon(lat, long); // Pass in decimal lat, long.\r\n        const gridref = latlong.toOsGrid(); // Convert to Lat-Long\r\n\r\n        return gridref; // Return a OSGB Object containing the easting and northing.\r\n    }\r\n\r\n    // getOSGB_FromDms() - Get OSGB From Degrees, Mins, Seconds.\r\n    /*\r\n        @param latdeg : The Latitude Degree\r\n        @param latmin : The lattitude Minute\r\n        @param latsec : The Lattitude Second\r\n        @param longdeg : The Longitude Degree\r\n        @param longmin : The Longitude Minute\r\n        @param longsec : The Longitude Second\r\n        @param datum : [OPTIONAL] the Datum code, defaulted to null = WGS84\r\n\r\n        @return : easting and northing from OS Grid Ref\r\n    */\r\n    getOSGB_FromDMS(latdeg, latmin, latsec, longdeg, longmin, longsec, datum = null) {\r\n        // If no datum supplied, the datum will default to WGS84\r\n        if (datum == null) {\r\n            datum = datums.WGS84;\r\n        }\r\n\r\n        // Convert params to degree from decimal\r\n        const LAT = this.getDecimalFromDegree(latdeg, latmin, latsec);\r\n        const LONG = this.getDecimalFromDegree(longdeg, longmin, longsec);\r\n\r\n        const latlong = new LatLon(LAT, LONG);\r\n        const gridref = latlong.toOsGrid();\r\n\r\n        return gridref;\r\n    }\r\n\r\n    // getLatLong_FromOSGB() - Get Lat Long From OSGB\r\n    /*\r\n        @param easting : The OSGB Easting\r\n        @param northing : The OSGB Northing\r\n        @param datum : [OPTIONAL] the Datum code, defaulted to null = WGS84\r\n        \r\n        @return : lat-long object \r\n    */\r\n    getLatLong_FromOSGB(easting, northing, datum = null) {\r\n        // If no datum supplied, the datum will default to WGS84\r\n        if (datum == null) {\r\n            datum = datums.WGS84;\r\n        }\r\n\r\n        const osref = new OsGridRef(easting, northing);\r\n        const latlong = osref.toLatLon(datum);\r\n\r\n        return latlong;\r\n    }\r\n\r\n    // getDecimalFromDegree() - Converts a degree, minute and second into a Decimal\r\n    /*\r\n        @param easting : The OSGB Easting\r\n        @param northing : The OSGB Northing\r\n        @param datum : [OPTIONAL] the Datum code, defaulted to null = WGS84\r\n        \r\n        @return : decimal number\r\n    */\r\n    getDecimalFromDegree(deg, min, sec) {\r\n        let decDeg = deg;\r\n\r\n        // turns the decimal degree positive\r\n        if (decDeg < 0) decDeg *= -1;\r\n\r\n        decDeg += min / 60;\r\n        decDeg += sec / 3600;\r\n\r\n        // turns the decimal degree back to negative\r\n        if (deg < 0) decDeg *= -1;\r\n\r\n        return decDeg;\r\n    }\r\n\r\n    getDegreeFromDecimal(dec){\r\n        let posDec = dec;\r\n        if(dec < 0) posDec *= -1;\r\n\r\n        let deg = Number(posDec);\r\n        let min = Number(((posDec - deg) * 60));\r\n        let sec = (posDec - deg - min / 60) * 3600;\r\n\r\n        return [Number(dec), min, sec];\r\n    }\r\n}\r\n\r\nexport default CoordConverter;\r\n","import React, { useState, useRef } from \"react\";\r\nimport styled from \"styled-components\";\r\nimport Converter from \"../latlong_to_osgrid/coord_converter\";\r\n\r\nimport colors from \"../Common/colors\";\r\nimport fonts from \"../Common/fonts\";\r\n\r\nconst LatLongAreaStyled = styled.div`\r\n    grid-column: 2/12;\r\n    grid-row: 4/12;\r\n\r\n    background-color: white;\r\n    border-radius: 30px;\r\n\r\n    border-style: solid;\r\n    border-color: ${colors.darkBlue};\r\n    border-width: 5px;\r\n\r\n    display: grid;\r\n    grid-template-rows: repeat(7, 2fr);\r\n    grid-template-columns: repeat(7, 2fr);\r\n\r\n    font-family: ${fonts.titleFont};\r\n\r\n    & .LatInput {\r\n        grid-column: 2/4;\r\n        grid-row: 2/3;\r\n        text-align: center;\r\n        font-size: 1.5vw;\r\n    }\r\n    & .LongInput {\r\n        grid-column: 5/7;\r\n        grid-row: 2/3;\r\n        text-align: center;\r\n        font-size: 1.5vw;\r\n    }\r\n\r\n    & .ConvertButton {\r\n        grid-column: 3/6;\r\n        grid-row: 4/5;\r\n        font-size: 1.3vw;\r\n\r\n        display: block;\r\n        margin-left: auto;\r\n        margin-right: auto;\r\n\r\n        width: 17vw;\r\n    }\r\n\r\n    & .output {\r\n        grid-row: 6/7;\r\n        grid-column: 3/6;\r\n        font-size: 1.3vw;\r\n        text-align: center;\r\n    }\r\n\r\n    & .DecToDegButton {\r\n        grid-row: 4/5;\r\n        grid-column: 2/3;\r\n    }\r\n\r\n    & .ClearButton {\r\n        grid-column: 6/7;\r\n        grid-row: 4/5;\r\n    }\r\n`;\r\n\r\nconst LatLongArea = (props) => {\r\n    // States\r\n    const [isDecimal, setIsDecimal] = useState(true); // Decimal / Degree\r\n    const [buttonPlaceHolder, setButtonPlaceHolder] = useState(\"(Degrees)\"); // Decimal / Degree Text\r\n\r\n    // Input field References\r\n    const input1Ref = useRef(null);\r\n    const input2Ref = useRef(null);\r\n    const outputRef = useRef(null);\r\n\r\n    // Converter\r\n    const converter = new Converter();\r\n\r\n    // Flips Decimal to Degree\r\n    const latLongDecToDegHandler = () => {\r\n        CheckDecimalToDegree();\r\n        setIsDecimal(!isDecimal);\r\n\r\n        return;\r\n    };\r\n\r\n    const CheckDecimalToDegree = () => {\r\n        if (isDecimal) {\r\n            setButtonPlaceHolder(\"(Decimal)\");\r\n            return;\r\n        } else {\r\n            setButtonPlaceHolder(\"(Degrees)\");\r\n            return;\r\n        }\r\n    };\r\n\r\n    // Clears inputs and the output\r\n    const ClearTextHandler = () => {\r\n        input1Ref.current.value = \"\";\r\n        input2Ref.current.value = \"\";\r\n        outputRef.current.value = \"\";\r\n\r\n        console.log(\"ClearTextHandler(): Text cleared\");\r\n\r\n        return;\r\n    };\r\n\r\n    const convertHandler = () => {\r\n        let lat = Number(input1Ref.current.value);\r\n        let lon = Number(input2Ref.current.value);\r\n\r\n        let result = null;\r\n\r\n        // If inputs are empty - alert\r\n        if(input1Ref.current.value === \"\" || input2Ref.current.value === \"\"){\r\n            alert(\"Please enter an Latitude And a Longitude Value!\");\r\n            return;\r\n        }\r\n\r\n        // Try conversion\r\n        try {\r\n            if (isDecimal) {\r\n                result = converter.getOSGB_FromDec(lat, lon);\r\n                outputRef.current.value = `${Math.ceil(\r\n                    result.easting\r\n                )}, ${Math.ceil(result.northing)}`;\r\n            } else {\r\n                // Degree\r\n                // Get Degree from Decimal\r\n                const [latdeg, latmin, latsec] = converter.getDegreeFromDecimal(\r\n                    lat\r\n                );\r\n                const [londeg, lonmin, lonsec] = converter.getDegreeFromDecimal(\r\n                    lon\r\n                );\r\n\r\n                console.table(latdeg, latmin, latsec, londeg, lonmin, lonsec);\r\n\r\n                result = converter.getOSGB_FromDMS(\r\n                    latdeg,\r\n                    latmin,\r\n                    latsec,\r\n                    londeg,\r\n                    lonmin,\r\n                    lonsec\r\n                );\r\n\r\n                outputRef.current.value = `${Math.ceil(\r\n                    result.easting\r\n                )}, ${Math.ceil(result.northing)}`;\r\n            }\r\n        } catch (error) { // Catch if Easing or Northing is Invalid then Handle\r\n            // TODO HANDLE - Dynamically color input text\r\n\r\n            console.error(\"ERROR: INVALID Latitude / Longitude\");\r\n            alert(\"ERROR: INVALID Latitude / Longitude\");\r\n\r\n            return;\r\n        }\r\n\r\n        // Log Debug\r\n        // console.log(input1Ref.current.value);\r\n        // console.log(input2Ref.current.value);\r\n        // console.log(outputRef.current.value);\r\n        //console.log(\"convertHandler(): Clicked\");\r\n    };\r\n\r\n    return (\r\n        <LatLongAreaStyled>\r\n            <input\r\n                ref={input1Ref}\r\n                type=\"text\"\r\n                className=\"LatInput\"\r\n                placeholder=\"Latitude N\"\r\n            />\r\n\r\n            <input\r\n                ref={input2Ref}\r\n                type=\"text\"\r\n                className=\"LongInput\"\r\n                placeholder=\"Longitude E\"\r\n            />\r\n\r\n            <button\r\n                className=\"ConvertButton\"\r\n                onClick={convertHandler}\r\n            >\r\n                Convert\r\n            </button>\r\n\r\n            <button\r\n                className=\"DecToDegButton\"\r\n                onClick={() => latLongDecToDegHandler()}\r\n            >\r\n                Switch to {buttonPlaceHolder}\r\n            </button>\r\n\r\n            <button className=\"ClearButton\" onClick={() => ClearTextHandler()}>\r\n                Clear All\r\n            </button>\r\n\r\n            <input\r\n                ref={outputRef}\r\n                type=\"text\"\r\n                className=\"output\"\r\n                placeholder=\"Your OS Grid Reference\"\r\n            />\r\n        </LatLongAreaStyled>\r\n    );\r\n};\r\n\r\nexport default LatLongArea;\r\n","import React, { useState, useRef } from \"react\";\r\nimport styled from \"styled-components\";\r\nimport Converter from \"../latlong_to_osgrid/coord_converter\";\r\n\r\nimport colors from \"../Common/colors\";\r\nimport fonts from \"../Common/fonts\";\r\n\r\nconst OSGBAreaStyled = styled.div`\r\n    grid-column: 2/12;\r\n    grid-row: 4/12;\r\n\r\n    background-color: white;\r\n    border-radius: 30px;\r\n\r\n    border-style: solid;\r\n    border-color: ${colors.darkBlue};\r\n    border-width: 5px;\r\n\r\n    display: grid;\r\n    grid-template-rows: repeat(7, 2fr);\r\n    grid-template-columns: repeat(7, 2fr);\r\n\r\n    font-family: ${fonts.titleFont};\r\n\r\n    & .EastingInput {\r\n        grid-column: 2/4;\r\n        grid-row: 2/3;\r\n        text-align: center;\r\n        font-size: 1.5vw;\r\n    }\r\n\r\n    & .NorthingInput {\r\n        grid-column: 5/7;\r\n        grid-row: 2/3;\r\n        text-align: center;\r\n        font-size: 1.5vw;\r\n    }\r\n\r\n    & .ConvertButton {\r\n        grid-column: 3/6;\r\n        grid-row: 4/5;\r\n        font-size: 1.3vw;\r\n\r\n        display: block;\r\n        margin-left: auto;\r\n        margin-right: auto;\r\n\r\n        width: 17vw;\r\n    }\r\n\r\n    & .output {\r\n        grid-row: 6/7;\r\n        grid-column: 3/6;\r\n        font-size: 1.3vw;\r\n        text-align: center;\r\n    }\r\n\r\n    & .DecToDegButton {\r\n        grid-row: 4/5;\r\n        grid-column: 2/3;\r\n    }\r\n\r\n    & .ClearButton {\r\n        grid-column: 6/7;\r\n        grid-row: 4/5;\r\n    }\r\n`;\r\n\r\nconst OsgbArea = (props) => {\r\n    // States\r\n    const [isDecimal, setIsDecimal] = useState(true); // Decimal / Degree\r\n    const [buttonPlaceHolder, setButtonPlaceHolder] = useState(\"(Degrees)\"); // Decimal / Degree Text\r\n\r\n    // Input field References\r\n    const input1Ref = useRef(null);\r\n    const input2Ref = useRef(null);\r\n    const outputRef = useRef(null);\r\n\r\n    // Converter\r\n    const converter = new Converter();\r\n\r\n    // Flips Decimal to Degree\r\n    const latLongDecToDegHandler = () => {\r\n        CheckDecimalToDegree();\r\n        setIsDecimal(!isDecimal);\r\n\r\n        return;\r\n    };\r\n\r\n    const CheckDecimalToDegree = () => {\r\n        if (isDecimal) {\r\n            setButtonPlaceHolder(\"(Decimal)\");\r\n            return;\r\n        } else {\r\n            setButtonPlaceHolder(\"(Degrees)\");\r\n            return;\r\n        }\r\n    };\r\n\r\n    const ClearTextHandler = () => {\r\n        input1Ref.current.value = \"\";\r\n        input2Ref.current.value = \"\";\r\n        outputRef.current.value = \"\";\r\n\r\n        console.log(\"ClearTextHandler(): Text cleared\");\r\n\r\n        return;\r\n    };\r\n\r\n    const convertHandler = () => {\r\n        let eastingInput = Number(input1Ref.current.value);\r\n        let northingInput = Number(input2Ref.current.value);\r\n\r\n        let result = null;\r\n\r\n        if(input1Ref.current.value === \"\" || input2Ref.current.value === \"\"){\r\n            alert(\"Please enter an Easting And A Northing Value!\");\r\n            return;\r\n        }\r\n\r\n        // Try conversion\r\n        try {\r\n            if (isDecimal) {\r\n                result = converter.getLatLong_FromOSGB(eastingInput, northingInput);\r\n                outputRef.current.value = `${result}`;\r\n            } else {\r\n                //result = converter.getLatLong_FromOSGB(eastingInput, northingInput);\r\n                // Convert output to degrees\r\n            }\r\n        } catch (error) { // Catch if Easing or Northing is Invalid then Handle\r\n            // TODO HANDLE - Dynamically color input text\r\n            // If inputs are empty - alert\r\n            console.error(\"ERROR: INVALID EASTING / NORTHING\");\r\n            alert(\"ERROR: INVALID EASTING / NORTHING\");\r\n\r\n            return;\r\n        }\r\n\r\n        // Log Debug\r\n        // console.log(input1Ref.current.value);\r\n        // console.log(input2Ref.current.value);\r\n        // console.log(outputRef.current.value);\r\n        //console.log(\"convertHandler(): Clicked\");\r\n    };\r\n\r\n    return (\r\n        <OSGBAreaStyled>\r\n            <input\r\n                ref={input1Ref}\r\n                type=\"text\"\r\n                className=\"EastingInput\"\r\n                placeholder=\"Easting\"\r\n            />\r\n\r\n            <input\r\n                ref={input2Ref}\r\n                type=\"text\"\r\n                className=\"NorthingInput\"\r\n                placeholder=\"Northing\"\r\n            />\r\n\r\n            <button className=\"ConvertButton\" onClick={convertHandler}>\r\n                Convert\r\n            </button>\r\n\r\n            <button className=\"DecToDegButton\" onClick={() => latLongDecToDegHandler()} >\r\n                Switch to {buttonPlaceHolder}\r\n            </button>\r\n\r\n            <button className=\"ClearButton\" onClick={() => ClearTextHandler()}>\r\n                Clear All\r\n            </button>\r\n\r\n            <input\r\n                ref={outputRef}\r\n                type=\"text\"\r\n                className=\"output\"\r\n                placeholder=\"Your Latitude and Longitude\"\r\n            />\r\n        </OSGBAreaStyled>\r\n    );\r\n};\r\n\r\nexport default OsgbArea;\r\n","import React, { useState } from \"react\";\r\nimport styled from \"styled-components\";\r\n\r\nimport colors from \"../Common/colors\";\r\n\r\n// Components\r\nimport LatLongArea from \"./LatLongArea\";\r\nimport OsgbArea from \"./OsgbArea\";\r\n\r\nconst BodyContainerDiv = styled.div`\r\n    background-color: ${colors.lightPurple};\r\n    grid-row: 3/14;\r\n    grid-column: 2/12;\r\n    border-radius: 30px;\r\n    border-style: solid;\r\n    border-color: ${colors.darkBlue};\r\n    border-width: 20px;\r\n\r\n    display: grid;\r\n    grid-template-columns: repeat(12, 2fr);\r\n    grid-template-rows: repeat(12, 2fr);\r\n`;\r\n\r\nconst ImageArrow = styled.img`\r\n    grid-row: 2/3;\r\n    grid-column: 6/8;\r\n    padding-top: 10px;\r\n    display: block;\r\n    margin-left: auto;\r\n    margin-right: auto;\r\n    transform: ${(props) => props.flipDirection};\r\n`;\r\n\r\nconst LatLongButton = styled.button`\r\n    grid-row: 2/3;\r\n    grid-column: 2/6;\r\n\r\n    font-size: 1.5vw;\r\n    border-radius: 30px;\r\n    border-style: solid;\r\n    border-color: ${colors.darkBlue};\r\n    border-width: 5px;\r\n    width: 50%;\r\n    display: block;\r\n    margin-left: auto;\r\n    margin-right: auto;\r\n\r\n    background-color: ${(props) => props.activeColor};\r\n    color: black;\r\n`;\r\n\r\nconst OsgbButton = styled.button`\r\n    grid-row: 2/3;\r\n    grid-column: 8/12;\r\n\r\n    font-size: 1.5vw;\r\n    border-radius: 30px;\r\n\r\n    border-style: solid;\r\n    border-color: ${colors.darkBlue};\r\n    border-width: 5px;\r\n    width: 50%;\r\n    display: block;\r\n    margin-left: auto;\r\n    margin-right: auto;\r\n\r\n    background-color: ${(props) => props.activeColor};\r\n    color: black;\r\n`;\r\n\r\n// TODO: Implement LatLong and Osgb Input Area Components\r\n// Refer to FIGMA DESIGN\r\n\r\nconst BodyContainer = () => {\r\n    const [LatLongButtonClicked, setLatLongButtonClicked] = useState(true); // Renders first and Enabled\r\n    const [OsgbButtonClicked, setOsgbButtonClicked] = useState(false); // Not rendered and Disabled\r\n\r\n    const LatLongButtonHandler = () => {\r\n        // Render LatLong Area\r\n        setOsgbButtonClicked(!OsgbButtonClicked);\r\n        setLatLongButtonClicked(!LatLongButtonClicked); // Flip\r\n\r\n        console.log(`LatLong: ${LatLongButtonClicked}`);\r\n        console.log(`OSGB: ${OsgbButtonClicked}`);\r\n    };\r\n\r\n    const OsgbButtonHandler = () => {\r\n        setOsgbButtonClicked(!OsgbButtonClicked);\r\n        setLatLongButtonClicked(!LatLongButtonClicked); // Flip\r\n\r\n        console.log(`LatLong: ${LatLongButtonClicked}`);\r\n        console.log(`OSGB: ${OsgbButtonClicked}`);\r\n    };\r\n\r\n    const switchAreas = () => {\r\n        if (LatLongButtonClicked) {\r\n            return <LatLongArea />;\r\n        } else if (OsgbButtonClicked) {\r\n            return <OsgbArea />;\r\n        } else {\r\n            console.log(\"Error: Neither Areas are rendering...\");\r\n        }\r\n    };\r\n\r\n    return (\r\n        <BodyContainerDiv>\r\n            <LatLongButton\r\n                activeColor={\r\n                    LatLongButtonClicked ? colors.activeGreen : \"white\"\r\n                }\r\n                disabled={LatLongButtonClicked}\r\n                onClick={() => LatLongButtonHandler()}\r\n            >\r\n                Lat/Long\r\n            </LatLongButton>\r\n            <ImageArrow\r\n                src={\"/img/arrow.png\"}\r\n                flipDirection={\r\n                    LatLongButtonClicked ? \"scaleX(-1)\" : \"scaleX(1)\"\r\n                }\r\n            />\r\n            <OsgbButton\r\n                activeColor={OsgbButtonClicked ? colors.activeGreen : \"white\"}\r\n                disabled={OsgbButtonClicked}\r\n                onClick={() => OsgbButtonHandler()}\r\n            >\r\n                OSGB\r\n            </OsgbButton>\r\n\r\n            {switchAreas()}\r\n            \r\n        </BodyContainerDiv>\r\n    );\r\n};\r\n\r\nexport default BodyContainer;\r\n","// Libs\r\nimport React from \"react\";\r\nimport { Helmet } from \"react-helmet\";\r\nimport styled from \"styled-components\";\r\n\r\n// CSS\r\nimport \"./Components/reset.css\";\r\nimport \"./Components/globals.css\";\r\n\r\n// Components\r\nimport Header from \"./Components/Header\";\r\nimport Footer from \"./Components/Footer\";\r\nimport BodyContainer from \"./Components/BodyContainer\";\r\n\r\n// 12 column grid for the page - wrapping grid\r\nconst PageGridContainerDiv = styled.div`\r\n    display: grid;\r\n    grid-template-columns: 2fr repeat(10, 1fr) 2fr;\r\n    grid-template-rows: 2fr repeat(13, 1fr) 2.12fr;\r\n`;\r\n\r\nconst App = () => {\r\n    return (\r\n        <>\r\n            <Helmet>\r\n                {/* ABeeZee font - google fonts */}\r\n                <link\r\n                    href=\"https://fonts.googleapis.com/css2?family=ABeeZee:ital@1&display=swap\"\r\n                    rel=\"stylesheet\"\r\n                />\r\n                {/* Fredoka One - Google fonts */}\r\n                <link\r\n                    href=\"https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap\"\r\n                    rel=\"stylesheet\"\r\n                />\r\n            </Helmet>\r\n            <PageGridContainerDiv>\r\n                <Header />\r\n                <BodyContainer /> {/* Main Application */}\r\n                <Footer />\r\n            </PageGridContainerDiv>\r\n        </>\r\n    );\r\n};\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.0/8 are considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { 'Service-Worker': 'script' },\r\n  })\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready\r\n      .then(registration => {\r\n        registration.unregister();\r\n      })\r\n      .catch(error => {\r\n        console.error(error.message);\r\n      });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport App from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}